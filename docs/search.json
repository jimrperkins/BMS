[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "BMS",
    "section": "",
    "text": "Preface\nEste material está diseñado para acompañar las sesiones prácticas de la asignatura “Biología Molecular de Sistemas”, que forma parte del grado de Bioquímica en la Universidad de Málaga. Se divide en 3 partes: una reintroducción a R, que estudiarás en un seminario de una hora, y 2 partes más extensas, donde utilizarás R para construir y analizar redes biológicas.",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "reintro_a_r.html",
    "href": "reintro_a_r.html",
    "title": "1  (Re)introducción a R para Biología y Bioinformática",
    "section": "",
    "text": "1.1 Objetivos\nAl final de este tutorial, podrás:",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>(Re)introducción a R para Biología y Bioinformática</span>"
    ]
  },
  {
    "objectID": "reintro_a_r.html#objetivos",
    "href": "reintro_a_r.html#objetivos",
    "title": "1  (Re)introducción a R para Biología y Bioinformática",
    "section": "",
    "text": "Entender la sintaxis básica y la estructura de R.\nRealizar operaciones simples con datos.\nCrear gráficos básicos relevantes para la biología y la bioinformática.\nEntender los conceptos básicos del análisis de redes con igraph.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>(Re)introducción a R para Biología y Bioinformática</span>"
    ]
  },
  {
    "objectID": "reintro_a_r.html#comenzando",
    "href": "reintro_a_r.html#comenzando",
    "title": "1  (Re)introducción a R para Biología y Bioinformática",
    "section": "1.2 Comenzando",
    "text": "1.2 Comenzando\nR es un lenguaje poderoso para la computación estadística y gráfica, ampliamente utilizado en bioinformática. Para empezar a usar R, necesitas tener R y RStudio instalados en tu ordenador. Puedes descargarlos desde los siguientes enlaces: - Descargar R - Descargar RStudio",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>(Re)introducción a R para Biología y Bioinformática</span>"
    ]
  },
  {
    "objectID": "reintro_a_r.html#sintaxis-básica",
    "href": "reintro_a_r.html#sintaxis-básica",
    "title": "1  (Re)introducción a R para Biología y Bioinformática",
    "section": "1.3 Sintaxis Básica",
    "text": "1.3 Sintaxis Básica\nComencemos con algunos comandos y operaciones básicas en R. Abre RStudio y prueba los siguientes ejemplos.\n\n1.3.1 Asignación de Variables\nEn R, puedes asignar valores a variables utilizando el operador &lt;-. Una variable es una forma de almacenar información que puedes usar y manipular más adelante.\n\n# Asignar longitudes de secuencias de ADN a variables\nlength_gene1 &lt;- 1500\nlength_gene2 &lt;- 1200\n\n# Imprimir las variables\nlength_gene1\n\n[1] 1500\n\nlength_gene2\n\n[1] 1200\n\n# Realizar operaciones con variables\ntotal_length &lt;- length_gene1 + length_gene2\ntotal_length\n\n[1] 2700\n\n\n\n\n1.3.2 Tipos de Datos\nR tiene varios tipos de datos, incluyendo numéricos (números), caracteres (texto) y lógicos (VERDADERO/FALSO).\n\n# Numérico\nsequence_length &lt;- 1500\nclass(sequence_length)\n\n[1] \"numeric\"\n\n# Caracter\nspecies &lt;- \"Homo sapiens\"\nclass(species)\n\n[1] \"character\"\n\n# Lógico\nis_protein_coding &lt;- TRUE\nclass(is_protein_coding)\n\n[1] \"logical\"\n\n\n\n\n1.3.3 Operaciones numéricas básicas\nEl contenido de GC se refiere al porcentaje de bases nitrogenadas guanina (G) y citosina (C) en una molécula de ADN. Es una medida importante porque:\n\nEstabilidad del ADN: Las regiones del ADN con alto contenido de GC son más estables debido al triple enlace de hidrógeno entre G y C, en comparación con el doble enlace de A y T.\nEvolución y Adaptación: Las diferencias en el contenido de GC pueden reflejar adaptaciones evolutivas a diferentes temperaturas ambientales, ya que las regiones con alto GC pueden ser más resistentes al calor.\nFunción Genómica: Algunas regiones funcionales del genoma, como los promotores de genes y las islas CpG, tienden a tener un alto contenido de GC, lo cual es crucial para la regulación genética.\n\n\n# Calcular el contenido de GC de una secuencia de ADN \ng &lt;- 200\nc &lt;- 180\na &lt;- 150\nt &lt;- 170\n# Número total de nucleótidos \ntotal_nt &lt;- g + c + a + t  \n# Porcentaje de contenido de GC \ngc_content &lt;- ((g + c) / total_nt) * 100 \ngc_content\n\n[1] 54.28571\n\n\n\n# Algunas operaciones extras son\n# la raiz\nsqrt(4)\n\n[1] 2\n\n# la exponencial\nexp(2)\n\n[1] 7.389056\n\n# elevar con una potencia\n2^3\n\n[1] 8\n\nsqrt(4)^2\n\n[1] 4",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>(Re)introducción a R para Biología y Bioinformática</span>"
    ]
  },
  {
    "objectID": "reintro_a_r.html#estructuras-de-datos-básicas",
    "href": "reintro_a_r.html#estructuras-de-datos-básicas",
    "title": "1  (Re)introducción a R para Biología y Bioinformática",
    "section": "1.4 Estructuras de Datos Básicas",
    "text": "1.4 Estructuras de Datos Básicas\nR proporciona varias estructuras de datos como vectores, matrices, listas y data frames. Vamos a explorar algunas de estas.\n\n1.4.1 Vectores\nLos vectores son la estructura de datos más básica en R y pueden contener una secuencia de elementos del mismo tipo.\n\n# Crear un vector numérico de longitudes de genes\ngene_lengths &lt;- c(1000, 1500, 2000, 2500, 3000)\ngene_lengths\n\n[1] 1000 1500 2000 2500 3000\n\n# Crear un vector de caracteres de nombres de genes\ngene_names &lt;- c(\"GeneA\", \"GeneB\", \"GeneC\", \"GeneD\", \"GeneE\")\ngene_names\n\n[1] \"GeneA\" \"GeneB\" \"GeneC\" \"GeneD\" \"GeneE\"\n\n\n\n# Algunas operaciones básicas con ellos\n1 + 3 * gene_lengths\n\n[1] 3001 4501 6001 7501 9001\n\nlength(gene_lengths)\n\n[1] 5\n\n# Extraer datos de vector\ngene_lengths[3]\n\n[1] 2000\n\ngene_lengths[2:5]\n\n[1] 1500 2000 2500 3000\n\ngene_lengths[c(2,5)]\n\n[1] 1500 3000\n\n\n\n\n1.4.2 Data Frames\nLos data frames se utilizan para almacenar datos tabulares. Piensa en un data frame como una tabla donde cada columna puede contener diferentes tipos de datos (numéricos, caracteres, etc.).\n\n# Crear un data frame con información de genes\ngenes_df &lt;- data.frame(\n  Name = gene_names,\n  Length = gene_lengths,\n  GC_Content = c(45, 50, 55, 47, 52)\n)\ngenes_df\n\n   Name Length GC_Content\n1 GeneA   1000         45\n2 GeneB   1500         50\n3 GeneC   2000         55\n4 GeneD   2500         47\n5 GeneE   3000         52\n\n\n\n# Extraer datos de dataframe\ngenes_df$Name       # Acceder a una columna por nombre\n\n[1] \"GeneA\" \"GeneB\" \"GeneC\" \"GeneD\" \"GeneE\"\n\ngenes_df[, \"Length\"] # Acceder a una columna por nombre usando índices\n\n[1] 1000 1500 2000 2500 3000\n\ngenes_df[1, ] # Acceder a la primera fila\n\n   Name Length GC_Content\n1 GeneA   1000         45\n\nclass(genes_df[1, ]) # miremos la clase de dato que devuelve\n\n[1] \"data.frame\"\n\ngenes_df[1:2,] \n\n   Name Length GC_Content\n1 GeneA   1000         45\n2 GeneB   1500         50\n\ngenes_df[c(1, 3),]\n\n   Name Length GC_Content\n1 GeneA   1000         45\n3 GeneC   2000         55\n\ngenes_df[c(1,3)]\n\n   Name GC_Content\n1 GeneA         45\n2 GeneB         50\n3 GeneC         55\n4 GeneD         47\n5 GeneE         52\n\n\n\n# obtener algunas metricas sobre el dataframe\ndim(genes_df)\n\n[1] 5 3\n\nsummary(genes_df)\n\n     Name               Length       GC_Content  \n Length:5           Min.   :1000   Min.   :45.0  \n Class :character   1st Qu.:1500   1st Qu.:47.0  \n Mode  :character   Median :2000   Median :50.0  \n                    Mean   :2000   Mean   :49.8  \n                    3rd Qu.:2500   3rd Qu.:52.0  \n                    Max.   :3000   Max.   :55.0",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>(Re)introducción a R para Biología y Bioinformática</span>"
    ]
  },
  {
    "objectID": "reintro_a_r.html#control-de-flujo",
    "href": "reintro_a_r.html#control-de-flujo",
    "title": "1  (Re)introducción a R para Biología y Bioinformática",
    "section": "1.5 Control de flujo",
    "text": "1.5 Control de flujo\n\n1.5.1 Reailzar tareas de forma iterativa\nEn ocasiones queremos llevar a cabo una misma tarea para distintos elementos de una lista, vector… o demás objetos iterables.\n\ndna &lt;- \"atcccgaggtagcgagcgtgca\"\ndna_vector &lt;- strsplit(dna, \"\")[[1]]\nfor (nucl in dna_vector) {\n    print(nucl)\n}\n\n[1] \"a\"\n[1] \"t\"\n[1] \"c\"\n[1] \"c\"\n[1] \"c\"\n[1] \"g\"\n[1] \"a\"\n[1] \"g\"\n[1] \"g\"\n[1] \"t\"\n[1] \"a\"\n[1] \"g\"\n[1] \"c\"\n[1] \"g\"\n[1] \"a\"\n[1] \"g\"\n[1] \"c\"\n[1] \"g\"\n[1] \"t\"\n[1] \"g\"\n[1] \"c\"\n[1] \"a\"\n\n\n\n\n1.5.2 Adición de condicionales\nSi en el flujo de trabajo queremos controlar lo que se haga según las circunstancias podemos utilizar lo siguiente.\n\ndna &lt;- \"atcccgaggtagcgagcgtgca\"\ndna_vector &lt;- strsplit(dna, \"\")[[1]]\ngc_content &lt;- 0\nfor (nucl in dna_vector) {\n    if ( nucl == \"g\" || nucl == \"c\" ) {\n      gc_content &lt;- gc_content + 1\n    }\n}\n(gc_content/length(dna_vector))*100\n\n[1] 63.63636",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>(Re)introducción a R para Biología y Bioinformática</span>"
    ]
  },
  {
    "objectID": "reintro_a_r.html#graficación-básica",
    "href": "reintro_a_r.html#graficación-básica",
    "title": "1  (Re)introducción a R para Biología y Bioinformática",
    "section": "1.6 Graficación Básica",
    "text": "1.6 Graficación Básica\nR es bien conocido por sus potentes capacidades de graficado. Aquí, crearemos un gráfico simple usando la función incorporada plot.\n\n1.6.1 Gráfico de Dispersión\n\n# Gráfico de dispersión básico de longitudes de genes vs contenido de GC\nplot(genes_df$Length, genes_df$GC_Content, main=\"Longitud de Genes vs Contenido de GC\", xlab=\"Longitud de Genes\", ylab=\"Contenido de GC (%)\")\n\n\n\n\n\n\n\n\n\n\n1.6.2 Histograma\n\n# Histograma básico de longitudes de genes\nhist(genes_df$Length, main=\"Distribución de Longitudes de Genes\", xlab=\"Longitud de Genes\", col=\"green\", border=\"black\")\n\n\n\n\n\n\n\n\n\n\n1.6.3 Boxplot\n\n# Boxplot básico de longitudes de genes \nboxplot(genes_df$Length, main=\"Distribución de Longitudes de Genes\", xlab=\"Longitud de Genes\", col=\"blue\", border=\"black\")\n\n\n\n\n\n\n\n\n\n\n1.6.4 Visualización de gráficas avanzada con ggplot2\n\nlibrary(ggplot2)\nggplot(genes_df, aes(x=Length)) + geom_boxplot(fill=\"slateblue\", alpha=0.2)\n\n\n\n\n\n\n\nggplot(genes_df, aes(x=Length, y=GC_Content)) + geom_point() + xlab(\"Longitud de Genes\") + ylab(\"Contenido de GC (%)\")",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>(Re)introducción a R para Biología y Bioinformática</span>"
    ]
  },
  {
    "objectID": "reintro_a_r.html#introducción-al-análisis-de-redes-con-igraph",
    "href": "reintro_a_r.html#introducción-al-análisis-de-redes-con-igraph",
    "title": "1  (Re)introducción a R para Biología y Bioinformática",
    "section": "1.7 Introducción al Análisis de Redes con igraph",
    "text": "1.7 Introducción al Análisis de Redes con igraph\nEl análisis de redes es un aspecto crucial de la bioinformática, especialmente en la comprensión de vías e interacciones biológicas. El paquete igraph en R es una herramienta poderosa para crear y analizar grafos.\n\n1.7.1 Instalación y Carga de igraph\nPrimero, necesitas cargar el paquete igraph.\n¿Qué es un Paquete en R? En R, un paquete es una colección de funciones, datos y código que extienden las capacidades básicas del lenguaje. Los paquetes son creados por la comunidad de R y están diseñados para abordar tareas específicas, desde análisis estadísticos avanzados hasta visualización de datos y manejo de datos biológicos. Los paquetes facilitan el trabajo con R al proporcionar herramientas adicionales que puedes usar en tus scripts y análisis.\nInstalación y Carga de Paquetes Para utilizar un paquete en R, primero necesitas instalarlo (si no está ya instalado) y luego cargarlo en tu sesión de R.\nInstalación de Paquetes Puedes instalar un paquete desde CRAN (Comprehensive R Archive Network) utilizando la función install.packages():\nAhora vamos a cargar un paquee que ya esta instalado, usando el comando library()\n\n# Cargar paquete igraph\nlibrary(igraph)\n\n\nAdjuntando el paquete: 'igraph'\n\n\nThe following objects are masked from 'package:stats':\n\n    decompose, spectrum\n\n\nThe following object is masked from 'package:base':\n\n    union\n\n\n\n\n1.7.2 Creación de una Red Simple\nRepresentar proteínas en un formato de red puede ser útil por varias razones:\n\nVisualización de Interacciones: Permite ver cómo las proteínas interactúan entre sí y formar una visión general de las redes de interacción.\nIdentificación de Proteínas Clave: Ayuda a identificar proteínas que tienen un papel central o que son esenciales en la red.\nAnálisis de Funciones Biológicas: Facilita la comprensión de las funciones biológicas y cómo las alteraciones en una proteína pueden afectar toda la red.\n\nVamos a crear una red simple de interacciones proteína-proteína.\n\n# Definir aristas (interacciones) entre proteínas\nedges &lt;- c(\"ProteinA\", \"ProteinB\",\n           \"ProteinA\", \"ProteinC\",\n           \"ProteinB\", \"ProteinC\",\n           \"ProteinB\", \"ProteinD\",\n           \"ProteinB\", \"ProteinE\",\n           \"ProteinC\", \"ProteinE\")\n\n# Crear un objeto de grafo\ng &lt;- graph(edges, directed=FALSE)\n\n\n# Extracción de principales objetos\nV(g)\n\n+ 5/5 vertices, named, from 4196d7a:\n[1] ProteinA ProteinB ProteinC ProteinD ProteinE\n\nE(g)\n\n+ 6/6 edges from 4196d7a (vertex names):\n[1] ProteinA--ProteinB ProteinA--ProteinC ProteinB--ProteinC ProteinB--ProteinD\n[5] ProteinB--ProteinE ProteinC--ProteinE\n\nV(g)$name\n\n[1] \"ProteinA\" \"ProteinB\" \"ProteinC\" \"ProteinD\" \"ProteinE\"\n\n\n\n# Graficar el grafo\nplot(g, vertex.label=V(g)$name, main=\"Red de Interacción Proteína-Proteína\")\n\n\n\n\n\n\n\n\n\n# Incorporar vértices\ng &lt;- add_vertices(g, 1, name = \"NewProtein\")\nplot(g, vertex.label=V(g)$name, main=\"Red de Interacción Proteína-Proteína\")\n\n\n\n\n\n\n\n# Incorporar edges\ng &lt;- add_edges(g, edges = c(\"ProteinD\", \"NewProtein\"), directed=FALSE)\nplot(g, vertex.label=V(g)$name, main=\"Red de Interacción Proteína-Proteína\")\n\n\n\n\n\n\n\n\n\n\n1.7.3 Análisis de la Red\nPuedes realizar varios análisis en la red, como encontrar el grado de cada nodo.\n\n# Calcular el grado de cada nodo\ndegree(g)\n\n  ProteinA   ProteinB   ProteinC   ProteinD   ProteinE NewProtein \n         2          4          3          2          2          1 \n\nbetweenness(g)\n\n  ProteinA   ProteinB   ProteinC   ProteinD   ProteinE NewProtein \n       0.0        6.5        0.5        4.0        0.0        0.0 \n\n# Graficar el grafo con tamaños de nodo proporcionales a su grado\nplot(g, vertex.size=degree(g)*10, vertex.label=V(g)$name, main=\"Red IPP (Tamaño de nodo ~Grado)\")\n\n\n\n\n\n\n\n\n\nhist(degree(g), main=\"Distribución del grado de los nodos\", xlab=\"\", col=\"blue\", border=\"black\")\n\n\n\n\n\n\n\nplot(betweenness(g), degree(g), main=\"Betweenness vs degree\", xlab=\"Betweenness\", ylab=\"Degree\")\n\n\n\n\n\n\n\n\n\n\n1.7.4 Otro ejemplo de red\n\ngraph_example &lt;- make_graph(\"Zachary\")\n# Se puede establecer el tipo de layout que quieres...layout_with_kk, layout_in_circle,...\nlayout &lt;- layout_with_fr(graph_example)\nplot(graph_example, layout = layout, vertex.size = 20, vertex.label = NA, vertex.color = \"skyblue\", edge.arrow.size = 0.5, edge.color = \"gray\") \n\n\n\n\n\n\n\nlayout &lt;- layout_with_kk(graph_example)\nplot(graph_example, layout = layout, vertex.size = 20, vertex.label = NA, vertex.color = \"skyblue\", edge.arrow.size = 0.5, edge.color = \"gray\")\n\n\n\n\n\n\n\nlayout &lt;- layout_in_circle(graph_example)\nplot(graph_example, layout = layout, vertex.size = 20, vertex.label = NA, vertex.color = \"skyblue\", edge.arrow.size = 0.5, edge.color = \"gray\")\n\n\n\n\n\n\n\n\n\nlayout &lt;- layout_with_fr(graph_example)\nplot(graph_example, layout = layout, vertex.size = degree(graph_example), vertex.label = NA, vertex.color = \"skyblue\", edge.arrow.size = 0.5, edge.color = \"gray\")",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>(Re)introducción a R para Biología y Bioinformática</span>"
    ]
  },
  {
    "objectID": "reintro_a_r.html#conclusión",
    "href": "reintro_a_r.html#conclusión",
    "title": "1  (Re)introducción a R para Biología y Bioinformática",
    "section": "1.8 Conclusión",
    "text": "1.8 Conclusión\nAhora has sido introducido a los conceptos básicos de la programación en R con ejemplos relevantes para la biología y la bioinformática. Hemos cubierto operaciones aritméticas básicas, asignación de variables, tipos de datos, estructuras de datos, graficación simple y una introducción al análisis de redes con igraph. Continúa practicando para familiarizarte más con R y explora temas más avanzados a medida que progresas.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>(Re)introducción a R para Biología y Bioinformática</span>"
    ]
  },
  {
    "objectID": "reintro_a_r.html#recursos-adicionales",
    "href": "reintro_a_r.html#recursos-adicionales",
    "title": "1  (Re)introducción a R para Biología y Bioinformática",
    "section": "1.9 Recursos Adicionales",
    "text": "1.9 Recursos Adicionales\nAquí hay algunos recursos para ayudarte a seguir aprendiendo R y bioinformática: - Documentación de R - Bioconductor - Hojas de Referencia de RStudio",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>(Re)introducción a R para Biología y Bioinformática</span>"
    ]
  },
  {
    "objectID": "hpo_redes1.html",
    "href": "hpo_redes1.html",
    "title": "2  Practica Redes 1: Análisis de redes con R y iGRAPH:",
    "section": "",
    "text": "2.0.1 Objetivos",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Practica Redes 1: Análisis de redes con R y iGRAPH:</span>"
    ]
  },
  {
    "objectID": "hpo_redes1.html#parte-1-descargar-la-lista-de-genes-de-la-hpo",
    "href": "hpo_redes1.html#parte-1-descargar-la-lista-de-genes-de-la-hpo",
    "title": "2  Practica Redes 1: Análisis de redes con R y iGRAPH:",
    "section": "2.1 Parte 1: Descargar la Lista de Genes de la HPO",
    "text": "2.1 Parte 1: Descargar la Lista de Genes de la HPO\n\n2.1.1 Descarga Manual\n\nNavega al sitio web de la Ontología de Fenotipos Humanos (HPO).\nBusca abnormal renal corpuscle morphology en la barra de búsqueda.\nHaz clic en el fenotipo para ver los detalles.\nLocaliza la lista de genes asociados y descárgala en formato de texto (Export Associations).\n\nANOTA el codigo HPO del fenotipo, nos va a hacer falta para el siguiente paso:\n\n\n2.1.2 Uso de la API\n\n2.1.2.1 ¿Qué es una API?\nUna Interfaz de Programación de Aplicaciones (API) permite que diferentes aplicaciones de software se comuniquen entre sí. En nuestro caso, nos permite acceder programáticamente a datos de la HPO. Puedes usar una API para obtener automáticamente la lista de genes sin tener que descargarla manualmente.\nPara usar la API, aquí hay un ejemplo de cómo obtener genes programáticamente. Primero, necesitamos instalar y cargar las bibliotecas necesarias:\n\n# Install necessary packages if not already installed\nif (!requireNamespace(\"httr\", quietly = TRUE)) {\n  install.packages(\"httr\")\n}\nif (!requireNamespace(\"jsonlite\", quietly = TRUE)) {\n  install.packages(\"jsonlite\")\n}\n\nlibrary(httr)\nlibrary(jsonlite)\n\n# API request to get genes associated with the HPO term for abnormal renal corpuscle morphology\nhpo_id &lt;- \"HP:0031263\"  # HPO ID for abnormal renal corpuscle morphology\n\nurl &lt;- paste0(\"https://ontology.jax.org/api/network/annotation/\", hpo_id)\n\nresponse &lt;- GET(url)\ndata &lt;- content(response, as = \"text\", encoding = \"UTF-8\")\ngenes &lt;- fromJSON(data)$genes\n\n# Display the first few genes\nhead(genes)\n\n# Display all the genes\nprint(genes)\n\n\n\n\n2.1.3 Preguntas\n¿Qué función cumple requireNamespace() en el contexto de la instalación de paquetes en R?\nRespuesta: requireNamespace() verifica si un paquete está instalado y disponible para ser utilizado sin cargarlo en el entorno de trabajo. Esto es importante porque permite comprobar la disponibilidad de un paquete antes de intentar usarlo, evitando errores si el paquete no está instalado. Si el paquete no está disponible, se puede instalar automáticamente con install.packages(), asegurando que el código se ejecute sin interrupciones.\nEn la línea url &lt;- paste0(\"https://ontology.jax.org/api/network/annotation/\", hpo_id), ¿qué papel juega paste0() en la construcción de la URL?\nRespuesta: paste0() se utiliza para concatenar cadenas de texto sin ningún separador. En este caso, une la parte estática de la URL con el identificador HPO (hpo_id). Si se utilizara paste() en lugar de paste0(), el resultado podría incluir un espacio adicional, lo que generaría una URL incorrecta. Por ejemplo, paste() usaría un espacio por defecto como separador entre los elementos concatenados, lo que provocaría un error al intentar acceder a la URL.\n¿Cuál es el propósito de las funciones GET() y content() en este código?\nRespuesta: La función GET() realiza una solicitud HTTP para obtener datos de la URL especificada. En este caso, se utiliza para recuperar información sobre genes asociados con un término HPO. La función content() procesa la respuesta de la solicitud, extrayendo el contenido del cuerpo de la respuesta en un formato específico (en este caso, como texto). Después, fromJSON() convierte ese texto JSON en un objeto R que puede manipularse fácilmente. Se espera que el objeto resultante contenga una lista de genes que se pueden utilizar para análisis posteriores.\n¿Cuáles son las ventajas de descargar datos directamente de una API?\nRespuesta: Utilizar una API permite obtener datos de manera automática, lo que puede ahorrar tiempo y reducir errores. Las API también suelen proporcionar datos actualizados y en un formato estructurado, lo que facilita su análisis.\n¿Cuáles podrían ser algunas limitaciones o desafíos de usar una API para la recuperación de datos?\nRespuesta: Algunas limitaciones pueden incluir la necesidad de una conexión a internet, la posibilidad de que la API tenga restricciones de uso o limitaciones en la cantidad de datos que se pueden solicitar a la vez. También puede haber problemas de compatibilidad si los datos devueltos por la API cambian.\n¿Puedes encontrar una función que te diga cuántas filas hay en el objeto genes? ¿Qué representa este número? ¿Cómo se compara con los resultados del web de HPO?\nRespuesta: Para contar cuántas filas hay en el objeto genes, puedes usar la función nrow() en R. Esta función devuelve el número de filas de un marco de datos o de una matriz. Este número representa la cantidad de genes que se han asociado con el fenotipo de interés, en este caso, morfología anormal del corpúsculo renal. Cada fila en el objeto genes corresponde a un gen único relacionado con ese fenotipo. Debe ser igual que el numero encontrado por el Web.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Practica Redes 1: Análisis de redes con R y iGRAPH:</span>"
    ]
  },
  {
    "objectID": "hpo_redes1.html#parte-2-obtención-de-la-red-de-interacción-con-stringdb",
    "href": "hpo_redes1.html#parte-2-obtención-de-la-red-de-interacción-con-stringdb",
    "title": "2  Practica Redes 1: Análisis de redes con R y iGRAPH:",
    "section": "2.2 Parte 2: Obtención de la Red de Interacción con STRINGdb",
    "text": "2.2 Parte 2: Obtención de la Red de Interacción con STRINGdb\nUna vez que hemos obtenido la lista de genes asociados con el fenotipo de morfología anormal del corpúsculo renal, el siguiente paso es explorar cómo estos genes interactúan entre sí. Para ello, utilizaremos la base de datos STRING (Search Tool for the Retrieval of Interacting Genes/Proteins), que proporciona información sobre las interacciones conocidas y pronosticadas entre proteínas y genes. Esta base de datos incluye información sobre interacciones de proteínas a nivel físico, funcional y de co-expresión, lo que es esencial para entender las vías biológicas y las redes de señalización involucradas en diversas condiciones fenotípicas.\nA través de la API de STRING, podemos obtener de manera programática una red de interacción que nos ayudará a visualizar y analizar las relaciones entre los genes de interés. Utilizaremos el paquete STRINGdb en R para acceder a estas interacciones y construir la red que analizaremos posteriormente.\nA continuación, aseguramos de que tienes el paquete STRINGdb instalado y luego procederemos a obtener la red de interacción.\n\n# Install the STRINGdb package if not already installed\nif (!requireNamespace(\"STRINGdb\", quietly = TRUE)) {\n  install.packages(\"STRINGdb\")\n}\n\nlibrary(STRINGdb)\n\n# Initialize STRINGdb with the appropriate version and species\nstring_db &lt;- STRINGdb$new(version = \"12\", species = 9606, score_threshold = 800, input_directory = \"\")\n\n# Fetch interactions for the gene list\n# Replace 'genes' with your actual gene list variable\ngene_ids &lt;- genes$name  # Adjust according to your downloaded data structure\nstring_ids &lt;- string_db$map( genes, \"name\", removeUnmappedRows = TRUE )\n\ninteraction_network &lt;- string_db$get_interactions(string_ids$STRING_id)\ninteraction_network &lt;- unique(interaction_network[, 1:2]) # necessary step to remove duplicate interactions\ninteraction_network$to &lt;- string_ids$name[match(interaction_network$to, string_ids$STRING_id)]\ninteraction_network$from &lt;- string_ids$name[match(interaction_network$from, string_ids$STRING_id)]\n\n# Display the first few rows of the interaction network\nhead(interaction_network)\n\n\n2.2.1 Preguntas\n¿Qué significa la línea string_db &lt;- STRINGdb$new(version = \"12\", species = 9606, score_threshold = 400, input_directory = \"\")?\nRespuesta: Esta línea inicializa un nuevo objeto STRINGdb, configurando la versión de la base de datos a utilizar (en este caso, la versión 12), especificando el organismo (especie humana, cuyo código es 9606) y estableciendo un umbral de puntuación de 400 para las interacciones que se consideran relevantes. El parámetro input_directory se deja vacío porque no se están usando archivos de entrada locales.\n¿Cuál es el propósito de la línea string_ids &lt;- string_db$mp(gene_ids)?\nRespuesta: La función mp() convierte los identificadores de genes (en este caso, almacenados en gene_ids) a los identificadores de STRING. Esto es necesario porque los genes pueden tener diferentes identificadores en diferentes bases de datos, y mp() asegura que se utilicen los correctos en la base de datos STRING.\n¿Por qué es importante establecer un score_threshold al inicializar STRINGdb?\nRespuesta: El score_threshold define el umbral mínimo de puntuación para las interacciones que se incluirán en la red. Interacciones con puntuaciones por debajo de este umbral serán excluidas, lo que ayuda a centrarse en las interacciones más relevantes y significativas y a reducir el ruido en los datos.\n¿Cuántas filas hay en el objeto interaction_network? ¿Qué representa este número? ¿Qué pasaría si repetimos el ejercicio aumentando el score_threshold?\nRespuesta: Este número representa la cantidad de interacciones que se han obtenido entre los genes de la red. Cada fila en el objeto interaction_network corresponde a una interacción única entre dos genes, donde se especifican detalles sobre la relación entre ellos. Si aumentamos el score_threshold, la red resultante seria mas pequeño.\n\n\n2.2.2 Explicación Adicional\nEn las redes biológicas, a menudo se utilizan redes no dirigidas porque la interacción entre genes no tiene una dirección específica, reflejando interacciones mutuas en lugar de influencias unidireccionales.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Practica Redes 1: Análisis de redes con R y iGRAPH:</span>"
    ]
  },
  {
    "objectID": "hpo_redes1.html#parte-3-conversión-a-formato-igraph-y-calculos-de-propiedades-de-una-red",
    "href": "hpo_redes1.html#parte-3-conversión-a-formato-igraph-y-calculos-de-propiedades-de-una-red",
    "title": "2  Practica Redes 1: Análisis de redes con R y iGRAPH:",
    "section": "2.3 Parte 3: Conversión a Formato igraph y calculos de propiedades de una red",
    "text": "2.3 Parte 3: Conversión a Formato igraph y calculos de propiedades de una red\nEn esta sección, convertiremos la red de interacción obtenida de STRINGdb al formato igraph. igraph es un paquete en R que proporciona herramientas para crear, manipular y analizar redes. Nos centraremos en calcular propiedades clave de la red que nos ayudarán a entender mejor su estructura.\nPrimero, asegúrate de tener instalado y cargado el paquete igraph:\n\n# Install igraph if it's not already installed\nif (!requireNamespace(\"igraph\", quietly = TRUE)) {\n  install.packages(\"igraph\")\n}\n\nlibrary(igraph)\n\n\n2.3.1 Conversión a Formato igraph\nPara convertir la red de interacción que hemos obtenido de STRINGdb a un objeto igraph, utilizaremos la función graph_from_data_frame(), que permite crear una red a partir de un data frame que contiene las interacciones.\nAsumamos que interaction_network tiene al menos dos columnas: gene1 y gene2, que representan los nodos conectados. La conversión se realiza de la siguiente manera:\n\n# Convert the interaction network downloaded from STRING into igraph format\ng &lt;- graph_from_data_frame(interaction_network, directed = FALSE)\n\n\n\n2.3.2 Cálculo de Propiedades de la Red\nUna vez que tenemos nuestra red en formato igraph, podemos calcular diversas propiedades que nos brindan información sobre su estructura y características. A continuación, se presentan algunas propiedades importantes que puedes calcular:\n\n2.3.2.1 Número de Nodos y Aristas\nPodemos calcular el número total de nodos y aristas en la red utilizando las funciones gorder() y gsize():\n\n# Calculate numbers of nodes and edges\nnum_nodes &lt;- gorder(g)  # Number of nodes\nnum_edges &lt;- gsize(g)  # Number of edges\n\ncat(\"Number of nodes:\", num_nodes, \"\\n\")\ncat(\"Number of edges:\", num_edges, \"\\n\")\n\n\n\n2.3.2.2 Grado Promedio de los Nodos\nEl grado de un nodo es el número de conexiones que tiene. Podemos calcular el grado promedio de todos los nodos en la red:\n\n# Calculate the degree (grado) of every node\ndegree_values &lt;- degree(g)\n\n# Calculate the average\naverage_degree &lt;- mean(degree_values)\ncat(\"Average degree of all nodes:\", average_degree, \"\\n\")\n\n\n\n2.3.2.3 Densidad de la Red\nLa densidad de una red es una medida que indica qué tan conectados están los nodos entre sí. Se calcula como el número de aristas dividido por el número máximo posible de aristas:\n\n# Calculate the density of the network\nnetwork_density &lt;- edge_density(g)\ncat(\"Network density:\", network_density, \"\\n\")\n\n\n\n2.3.2.4 Centralidad\nLa centralidad nos ayuda a identificar los nodos más importantes dentro de la red. Podemos calcular diferentes medidas de centralidad, aqui vemos centralidad de cercanía:\n\n# Calculate Closeness Centrality (centralidad de cercanía)\ncentrality_closeness &lt;- closeness(g)\n\n# Show results\ncat(\"Closeness Centrality (first 5 nodos):\", head(centrality_closeness, 5), \"\\n\")\n\n\n\n\n2.3.3 Preguntas\nDespués de calcular estas propiedades, reflexiona sobre las siguientes preguntas:\n¿Cuál es la importancia de crear una red no dirigido en el contexto de las interacciones génicas? Como hemos creado una red no dirigida?\nEn las redes biológicas, a menudo se utilizan redes no dirigidos porque la interacción entre genes no tiene una dirección específica, reflejando interacciones mutuas en lugar de influencias unidireccionales.\n¿Qué información proporcionan estas métricas sobre la red de interacción de genes?\nEl número de nodos y aristas nos muestra cuántos genes y cuántas interacciones hay en la red, proporcionando una idea de su complejidad. El grado promedio indica cuántas conexiones tiene cada gen en promedio, lo que refleja cuán interconectados están los genes. La densidad nos informa sobre la proporción de conexiones posibles que realmente ocurren, y la centralidad identifica genes clave que podrían desempeñar roles críticos en la red\n¿Hay nodos que se destacan por su grado o centralidad? ¿Cómo podría esto estar relacionado con sus funciones biológicas?\nLos nodos con mayor grado o centralidad suelen ser hubs dentro de la red, lo que significa que están muy conectados o son esenciales para la transmisión de información. En un contexto biológico, estos genes pueden estar implicados en funciones importantes o regulando varias vías. Si estos genes clave están relacionados con la morfología anormal del corpúsculo renal, podrían ser cruciales para entender las bases moleculares de esta enfermedad.\n¿Qué implicaciones podrían tener estas propiedades para entender la morfología anormal del corpúsculo renal?\nEl análisis de estas propiedades te ayudará a desarrollar una comprensión más profunda de las interacciones en la red y su relevancia en contextos biológicos.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Practica Redes 1: Análisis de redes con R y iGRAPH:</span>"
    ]
  },
  {
    "objectID": "hpo_redes1.html#parte-4-visualizando-la-red",
    "href": "hpo_redes1.html#parte-4-visualizando-la-red",
    "title": "2  Practica Redes 1: Análisis de redes con R y iGRAPH:",
    "section": "2.4 Parte 4: Visualizando la Red",
    "text": "2.4 Parte 4: Visualizando la Red\nUna vez que tenemos nuestra red en formato igraph, podemos proceder a realizar diversas visualizaciones y análisis estadísticos. La visualización es una parte crucial del análisis de redes, ya que nos ayuda a entender la distribución y la relación entre los diferentes nodos.\nEn esta sección, utilizaremos funciones del paquete igraph para crear gráficos visualmente informativos que representen las interacciones entre genes. Además, calcularemos estadísticas de la red, como el número de nodos e interacciones, lo que nos permitirá obtener una visión general de la complejidad y la conectividad de nuestra red. Esto es especialmente relevante en biología molecular, donde las interacciones entre genes pueden proporcionar información valiosa sobre funciones biológicas y mecanismos de enfermedades.\n\n2.4.1 Gráfico Básico\n\n# Basic plot of the network\nplot(g, vertex.size=5, vertex.label.cex=0.7, edge.arrow.size=0.5, main=\"Basic Interaction Network\")\n\n\n\n2.4.2 Visualizaciones Personalizadas\n\n2.4.2.1 Disposición de Fruchterman-Reingold\n\nlayout &lt;- layout_with_fr(g)  # Fruchterman-Reingold layout\nplot(g, layout = layout, vertex.color = \"skyblue\", vertex.size = 5, edge.width = 0.5, main = \"Fruchterman-Reingold Layout\")\n\n\n\n2.4.2.2 Disposición Circular\n\n# Help page access\n?layout_in_circle  # Recuerda cómo acceder a las páginas de ayuda\n\n# Plot with circular layout\ncircular_layout &lt;- layout_in_circle(g)\nplot(g, layout = circular_layout, vertex.color = \"lightgreen\", vertex.size = 5, edge.width = 0.5, main = \"Circular Layout\")\n\n\n\n2.4.2.3 Disposición “nice”\n\n# Plot with nicely layout\nnice_layout &lt;- layout_nicely(g)\nplot(g, layout = nice_layout, vertex.color = \"orange\", vertex.size = 5, edge.width = 0.5, main = \"Nicely Layout\")\n\n\n\n\n2.4.3 Preguntas\n¿Qué observas sobre la estructura de la red en diferentes disposiciones? ¿Hay áreas densamente conectadas?\nAl observar la estructura de la red en diferentes disposiciones, es posible notar que la disposición afecta la manera en que percibimos la organización de los nodos y las conexiones. En algunas disposiciones, como la disposición en círculo o en rejilla, la estructura general es más clara, pero puede ser difícil identificar áreas con conexiones densas. En cambio, otras \"visualizations\" tienden a agrupar de manera más natural los nodos más conectados, haciendo que las áreas densamente conectadas se resalten visualmente. Estas áreas densas, conocidas como clusters, suelen estar formadas por grupos de genes que interactúan de manera más fuerte entre sí, lo que podría indicar que participan en procesos biológicos similares o relacionados.\n¿Puedes identificar algunos hubs en la red? ¿Cuál podría ser su significado biológico?\nSí, es posible identificar agrupaciones claras en la red, conocidas como clusters o módulos, que suelen estar formadas por nodos (genes) que están densamente interconectados entre sí. Estas agrupaciones pueden reflejar grupos de genes que participan en funciones biológicas comunes, como rutas metabólicas, procesos celulares específicos o complejos proteicos. Veremos mas sobre como identificar estos grupos la semana que viene.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Practica Redes 1: Análisis de redes con R y iGRAPH:</span>"
    ]
  },
  {
    "objectID": "summary.html",
    "href": "summary.html",
    "title": "3  Summary",
    "section": "",
    "text": "In summary, this book has no content whatsoever.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Summary</span>"
    ]
  }
]