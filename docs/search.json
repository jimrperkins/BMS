[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "BMS",
    "section": "",
    "text": "Preface\nEste material está diseñado para acompañar las sesiones prácticas de la asignatura “Biología Molecular de Sistemas”, que forma parte del grado de Bioquímica en la Universidad de Málaga. Se divide en 3 partes: una reintroducción a R, que estudiarás en un seminario de una hora, y 2 partes más extensas, donde utilizarás R para construir y analizar redes biológicas.",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "reintro_a_r.html",
    "href": "reintro_a_r.html",
    "title": "1  (Re)introducción a R para Biología y Bioinformática",
    "section": "",
    "text": "1.1 Objetivos\nBienvenidos a la Reintroducción a R. En esta sesión de una hora, aprendereis y os recordaremos los conceptos básicos de la programación en R con ejemplos relacionados con la biología y la bioinformática, incluyendo una introducción al análisis de redes usando igraph.\nAl final de este tutorial, podrás:",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>(Re)introducción a R para Biología y Bioinformática</span>"
    ]
  },
  {
    "objectID": "reintro_a_r.html#objetivos",
    "href": "reintro_a_r.html#objetivos",
    "title": "1  (Re)introducción a R para Biología y Bioinformática",
    "section": "",
    "text": "Entender la sintaxis básica y la estructura de R.\nRealizar operaciones simples con datos.\nCrear gráficos básicos relevantes para la biología y la bioinformática.\nEntender los conceptos básicos del análisis de redes con igraph.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>(Re)introducción a R para Biología y Bioinformática</span>"
    ]
  },
  {
    "objectID": "reintro_a_r.html#comenzando",
    "href": "reintro_a_r.html#comenzando",
    "title": "1  (Re)introducción a R para Biología y Bioinformática",
    "section": "1.2 Comenzando",
    "text": "1.2 Comenzando\nR es un lenguaje poderoso para la computación estadística y gráfica, ampliamente utilizado en bioinformática. Para empezar a usar R, necesitas tener R y RStudio instalados en tu ordenador. Puedes descargarlos desde los siguientes enlaces: - Descargar R - Descargar RStudio",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>(Re)introducción a R para Biología y Bioinformática</span>"
    ]
  },
  {
    "objectID": "reintro_a_r.html#sintaxis-básica",
    "href": "reintro_a_r.html#sintaxis-básica",
    "title": "1  (Re)introducción a R para Biología y Bioinformática",
    "section": "1.3 Sintaxis Básica",
    "text": "1.3 Sintaxis Básica\nComencemos con algunos comandos y operaciones básicas en R. Abre RStudio y prueba los siguientes ejemplos.\n\n1.3.1 Asignación de Variables\nEn R, puedes asignar valores a variables utilizando el operador &lt;-. Una variable es una forma de almacenar información que puedes usar y manipular más adelante.\n\n# Asignar longitudes de secuencias de ADN a variables\nlength_gene1 &lt;- 1500\nlength_gene2 &lt;- 1200\n\n# Imprimir las variables\nlength_gene1\n\n[1] 1500\n\nlength_gene2\n\n[1] 1200\n\n# Realizar operaciones con variables\ntotal_length &lt;- length_gene1 + length_gene2\ntotal_length\n\n[1] 2700\n\n\n\n\n1.3.2 Tipos de Datos\nR tiene varios tipos de datos, incluyendo numéricos (números), caracteres (texto) y lógicos (VERDADERO/FALSO).\n\n# Numérico\nsequence_length &lt;- 1500\nclass(sequence_length)\n\n[1] \"numeric\"\n\n# Caracter\nspecies &lt;- \"Homo sapiens\"\nclass(species)\n\n[1] \"character\"\n\n# Lógico\nis_protein_coding &lt;- TRUE\nclass(is_protein_coding)\n\n[1] \"logical\"\n\n\n\n\n1.3.3 Operaciones numéricas básicas\nEl contenido de GC se refiere al porcentaje de bases nitrogenadas guanina (G) y citosina (C) en una molécula de ADN. Es una medida importante porque:\n\nEstabilidad del ADN: Las regiones del ADN con alto contenido de GC son más estables debido al triple enlace de hidrógeno entre G y C, en comparación con el doble enlace de A y T.\nEvolución y Adaptación: Las diferencias en el contenido de GC pueden reflejar adaptaciones evolutivas a diferentes temperaturas ambientales, ya que las regiones con alto GC pueden ser más resistentes al calor.\nFunción Genómica: Algunas regiones funcionales del genoma, como los promotores de genes y las islas CpG, tienden a tener un alto contenido de GC, lo cual es crucial para la regulación genética.\n\n\n# Calcular el contenido de GC de una secuencia de ADN \ng &lt;- 200\nc &lt;- 180\na &lt;- 150\nt &lt;- 170\n# Número total de nucleótidos \ntotal_nt &lt;- g + c + a + t  \n# Porcentaje de contenido de GC \ngc_content &lt;- ((g + c) / total_nt) * 100 \ngc_content\n\n[1] 54.28571\n\n\n\n# Algunas operaciones extras son\n# la raiz\nsqrt(4)\n\n[1] 2\n\n# la exponencial\nexp(2)\n\n[1] 7.389056\n\n# elevar con una potencia\n2^3\n\n[1] 8\n\nsqrt(4)^2\n\n[1] 4",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>(Re)introducción a R para Biología y Bioinformática</span>"
    ]
  },
  {
    "objectID": "reintro_a_r.html#estructuras-de-datos-básicas",
    "href": "reintro_a_r.html#estructuras-de-datos-básicas",
    "title": "1  (Re)introducción a R para Biología y Bioinformática",
    "section": "1.4 Estructuras de Datos Básicas",
    "text": "1.4 Estructuras de Datos Básicas\nR proporciona varias estructuras de datos como vectores, matrices, listas y data frames. Vamos a explorar algunas de estas.\n\n1.4.1 Vectores\nLos vectores son la estructura de datos más básica en R y pueden contener una secuencia de elementos del mismo tipo.\n\n# Crear un vector numérico de longitudes de genes\ngene_lengths &lt;- c(1000, 1500, 2000, 2500, 3000)\ngene_lengths\n\n[1] 1000 1500 2000 2500 3000\n\n# Crear un vector de caracteres de nombres de genes\ngene_names &lt;- c(\"GeneA\", \"GeneB\", \"GeneC\", \"GeneD\", \"GeneE\")\ngene_names\n\n[1] \"GeneA\" \"GeneB\" \"GeneC\" \"GeneD\" \"GeneE\"\n\n\n\n# Algunas operaciones básicas con ellos\n1 + 3 * gene_lengths\n\n[1] 3001 4501 6001 7501 9001\n\nlength(gene_lengths)\n\n[1] 5\n\n# Extraer datos de vector\ngene_lengths[3]\n\n[1] 2000\n\ngene_lengths[2:5]\n\n[1] 1500 2000 2500 3000\n\ngene_lengths[c(2,5)]\n\n[1] 1500 3000\n\n\n\n\n1.4.2 Data Frames\nLos data frames se utilizan para almacenar datos tabulares. Piensa en un data frame como una tabla donde cada columna puede contener diferentes tipos de datos (numéricos, caracteres, etc.).\n\n# Crear un data frame con información de genes\ngenes_df &lt;- data.frame(\n  Name = gene_names,\n  Length = gene_lengths,\n  GC_Content = c(45, 50, 55, 47, 52)\n)\ngenes_df\n\n   Name Length GC_Content\n1 GeneA   1000         45\n2 GeneB   1500         50\n3 GeneC   2000         55\n4 GeneD   2500         47\n5 GeneE   3000         52\n\n\n\n# Extraer datos de dataframe\ngenes_df$Name       # Acceder a una columna por nombre\n\n[1] \"GeneA\" \"GeneB\" \"GeneC\" \"GeneD\" \"GeneE\"\n\ngenes_df[, \"Length\"] # Acceder a una columna por nombre usando índices\n\n[1] 1000 1500 2000 2500 3000\n\ngenes_df[1, ] # Acceder a la primera fila\n\n   Name Length GC_Content\n1 GeneA   1000         45\n\nclass(genes_df[1, ]) # miremos la clase de dato que devuelve\n\n[1] \"data.frame\"\n\ngenes_df[1:2,] \n\n   Name Length GC_Content\n1 GeneA   1000         45\n2 GeneB   1500         50\n\ngenes_df[c(1, 3),]\n\n   Name Length GC_Content\n1 GeneA   1000         45\n3 GeneC   2000         55\n\ngenes_df[c(1,3)]\n\n   Name GC_Content\n1 GeneA         45\n2 GeneB         50\n3 GeneC         55\n4 GeneD         47\n5 GeneE         52\n\n\n\n# obtener algunas metricas sobre el dataframe\ndim(genes_df)\n\n[1] 5 3\n\nsummary(genes_df)\n\n     Name               Length       GC_Content  \n Length:5           Min.   :1000   Min.   :45.0  \n Class :character   1st Qu.:1500   1st Qu.:47.0  \n Mode  :character   Median :2000   Median :50.0  \n                    Mean   :2000   Mean   :49.8  \n                    3rd Qu.:2500   3rd Qu.:52.0  \n                    Max.   :3000   Max.   :55.0",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>(Re)introducción a R para Biología y Bioinformática</span>"
    ]
  },
  {
    "objectID": "reintro_a_r.html#control-de-flujo",
    "href": "reintro_a_r.html#control-de-flujo",
    "title": "1  (Re)introducción a R para Biología y Bioinformática",
    "section": "1.5 Control de flujo",
    "text": "1.5 Control de flujo\n\n1.5.1 Reailzar tareas de forma iterativa\nEn ocasiones queremos llevar a cabo una misma tarea para distintos elementos de una lista, vector… o demás objetos iterables.\n\ndna &lt;- \"atcccgaggtagcgagcgtgca\"\ndna_vector &lt;- strsplit(dna, \"\")[[1]]\nfor (nucl in dna_vector) {\n    print(nucl)\n}\n\n[1] \"a\"\n[1] \"t\"\n[1] \"c\"\n[1] \"c\"\n[1] \"c\"\n[1] \"g\"\n[1] \"a\"\n[1] \"g\"\n[1] \"g\"\n[1] \"t\"\n[1] \"a\"\n[1] \"g\"\n[1] \"c\"\n[1] \"g\"\n[1] \"a\"\n[1] \"g\"\n[1] \"c\"\n[1] \"g\"\n[1] \"t\"\n[1] \"g\"\n[1] \"c\"\n[1] \"a\"\n\n\n\n\n1.5.2 Adición de condicionales\nSi en el flujo de trabajo queremos controlar lo que se haga según las circunstancias podemos utilizar lo siguiente.\n\ndna &lt;- \"atcccgaggtagcgagcgtgca\"\ndna_vector &lt;- strsplit(dna, \"\")[[1]]\ngc_content &lt;- 0\nfor (nucl in dna_vector) {\n    if ( nucl == \"g\" || nucl == \"c\" ) {\n      gc_content &lt;- gc_content + 1\n    }\n}\n(gc_content/length(dna_vector))*100\n\n[1] 63.63636",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>(Re)introducción a R para Biología y Bioinformática</span>"
    ]
  },
  {
    "objectID": "reintro_a_r.html#graficación-básica",
    "href": "reintro_a_r.html#graficación-básica",
    "title": "1  (Re)introducción a R para Biología y Bioinformática",
    "section": "1.6 Graficación Básica",
    "text": "1.6 Graficación Básica\nR es bien conocido por sus potentes capacidades de graficado. Aquí, crearemos un gráfico simple usando la función incorporada plot.\n\n1.6.1 Gráfico de Dispersión\n\n# Gráfico de dispersión básico de longitudes de genes vs contenido de GC\nplot(genes_df$Length, genes_df$GC_Content, main=\"Longitud de Genes vs Contenido de GC\", xlab=\"Longitud de Genes\", ylab=\"Contenido de GC (%)\")\n\n\n\n\n\n\n\n\n\n\n1.6.2 Histograma\n\n# Histograma básico de longitudes de genes\nhist(genes_df$Length, main=\"Distribución de Longitudes de Genes\", xlab=\"Longitud de Genes\", col=\"green\", border=\"black\")\n\n\n\n\n\n\n\n\n\n\n1.6.3 Boxplot\n\n# Boxplot básico de longitudes de genes \nboxplot(genes_df$Length, main=\"Distribución de Longitudes de Genes\", xlab=\"Longitud de Genes\", col=\"blue\", border=\"black\")\n\n\n\n\n\n\n\n\n\n\n1.6.4 Visualización de gráficas avanzada con ggplot2\n\nlibrary(ggplot2)\nggplot(genes_df, aes(x=Length)) + geom_boxplot(fill=\"slateblue\", alpha=0.2)\n\n\n\n\n\n\n\nggplot(genes_df, aes(x=Length, y=GC_Content)) + geom_point() + xlab(\"Longitud de Genes\") + ylab(\"Contenido de GC (%)\")",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>(Re)introducción a R para Biología y Bioinformática</span>"
    ]
  },
  {
    "objectID": "reintro_a_r.html#introducción-al-análisis-de-redes-con-igraph",
    "href": "reintro_a_r.html#introducción-al-análisis-de-redes-con-igraph",
    "title": "1  (Re)introducción a R para Biología y Bioinformática",
    "section": "1.7 Introducción al Análisis de Redes con igraph",
    "text": "1.7 Introducción al Análisis de Redes con igraph\nEl análisis de redes es un aspecto crucial de la bioinformática, especialmente en la comprensión de vías e interacciones biológicas. El paquete igraph en R es una herramienta poderosa para crear y analizar grafos.\n\n1.7.1 Instalación y Carga de igraph\nPrimero, necesitas cargar el paquete igraph.\n¿Qué es un Paquete en R? En R, un paquete es una colección de funciones, datos y código que extienden las capacidades básicas del lenguaje. Los paquetes son creados por la comunidad de R y están diseñados para abordar tareas específicas, desde análisis estadísticos avanzados hasta visualización de datos y manejo de datos biológicos. Los paquetes facilitan el trabajo con R al proporcionar herramientas adicionales que puedes usar en tus scripts y análisis.\nInstalación y Carga de Paquetes Para utilizar un paquete en R, primero necesitas instalarlo (si no está ya instalado) y luego cargarlo en tu sesión de R.\nInstalación de Paquetes Puedes instalar un paquete desde CRAN (Comprehensive R Archive Network) utilizando la función install.packages():\nAhora vamos a cargar un paquee que ya esta instalado, usando el comando library()\n\n# Cargar paquete igraph\nlibrary(igraph)\n\n\nAttaching package: 'igraph'\n\n\nThe following objects are masked from 'package:stats':\n\n    decompose, spectrum\n\n\nThe following object is masked from 'package:base':\n\n    union\n\n\n\n\n1.7.2 Creación de una Red Simple\nRepresentar proteínas en un formato de red puede ser útil por varias razones:\n\nVisualización de Interacciones: Permite ver cómo las proteínas interactúan entre sí y formar una visión general de las redes de interacción.\nIdentificación de Proteínas Clave: Ayuda a identificar proteínas que tienen un papel central o que son esenciales en la red.\nAnálisis de Funciones Biológicas: Facilita la comprensión de las funciones biológicas y cómo las alteraciones en una proteína pueden afectar toda la red.\n\nVamos a crear una red simple de interacciones proteína-proteína.\n\n# Definir aristas (interacciones) entre proteínas\nedges &lt;- c(\"ProteinA\", \"ProteinB\",\n           \"ProteinA\", \"ProteinC\",\n           \"ProteinB\", \"ProteinC\",\n           \"ProteinB\", \"ProteinD\",\n           \"ProteinB\", \"ProteinE\",\n           \"ProteinC\", \"ProteinE\")\n\n# Crear un objeto de grafo\ng &lt;- graph(edges, directed=FALSE)\n\nWarning: `graph()` was deprecated in igraph 2.1.0.\nℹ Please use `make_graph()` instead.\n\n\n\n# Extracción de principales objetos\nV(g)\n\n+ 5/5 vertices, named, from 752fb04:\n[1] ProteinA ProteinB ProteinC ProteinD ProteinE\n\nE(g)\n\n+ 6/6 edges from 752fb04 (vertex names):\n[1] ProteinA--ProteinB ProteinA--ProteinC ProteinB--ProteinC ProteinB--ProteinD\n[5] ProteinB--ProteinE ProteinC--ProteinE\n\nV(g)$name\n\n[1] \"ProteinA\" \"ProteinB\" \"ProteinC\" \"ProteinD\" \"ProteinE\"\n\n\n\n# Graficar el grafo\nplot(g, vertex.label=V(g)$name, main=\"Red de Interacción Proteína-Proteína\")\n\n\n\n\n\n\n\n\n\n# Incorporar vértices\ng &lt;- add_vertices(g, 1, name = \"NewProtein\")\nplot(g, vertex.label=V(g)$name, main=\"Red de Interacción Proteína-Proteína\")\n\n\n\n\n\n\n\n# Incorporar edges\ng &lt;- add_edges(g, edges = c(\"ProteinD\", \"NewProtein\"), directed=FALSE)\nplot(g, vertex.label=V(g)$name, main=\"Red de Interacción Proteína-Proteína\")\n\n\n\n\n\n\n\n\n\n\n1.7.3 Análisis de la Red\nPuedes realizar varios análisis en la red, como encontrar el grado de cada nodo.\n\n# Calcular el grado de cada nodo\ndegree(g)\n\n  ProteinA   ProteinB   ProteinC   ProteinD   ProteinE NewProtein \n         2          4          3          2          2          1 \n\nbetweenness(g)\n\n  ProteinA   ProteinB   ProteinC   ProteinD   ProteinE NewProtein \n       0.0        6.5        0.5        4.0        0.0        0.0 \n\n# Graficar el grafo con tamaños de nodo proporcionales a su grado\nplot(g, vertex.size=degree(g)*10, vertex.label=V(g)$name, main=\"Red IPP (Tamaño de nodo ~Grado)\")\n\n\n\n\n\n\n\n\n\nhist(degree(g), main=\"Distribución del grado de los nodos\", xlab=\"\", col=\"blue\", border=\"black\")\n\n\n\n\n\n\n\nplot(betweenness(g), degree(g), main=\"Betweenness vs degree\", xlab=\"Betweenness\", ylab=\"Degree\")\n\n\n\n\n\n\n\n\n\n\n1.7.4 Otro ejemplo de red\n\ngraph_example &lt;- make_graph(\"Zachary\")\n# Se puede establecer el tipo de layout que quieres...layout_with_kk, layout_in_circle,...\nlayout &lt;- layout_with_fr(graph_example)\nplot(graph_example, layout = layout, vertex.size = 20, vertex.label = NA, vertex.color = \"skyblue\", edge.arrow.size = 0.5, edge.color = \"gray\") \n\n\n\n\n\n\n\nlayout &lt;- layout_with_kk(graph_example)\nplot(graph_example, layout = layout, vertex.size = 20, vertex.label = NA, vertex.color = \"skyblue\", edge.arrow.size = 0.5, edge.color = \"gray\")\n\n\n\n\n\n\n\nlayout &lt;- layout_in_circle(graph_example)\nplot(graph_example, layout = layout, vertex.size = 20, vertex.label = NA, vertex.color = \"skyblue\", edge.arrow.size = 0.5, edge.color = \"gray\")\n\n\n\n\n\n\n\n\n\nlayout &lt;- layout_with_fr(graph_example)\nplot(graph_example, layout = layout, vertex.size = degree(graph_example), vertex.label = NA, vertex.color = \"skyblue\", edge.arrow.size = 0.5, edge.color = \"gray\")",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>(Re)introducción a R para Biología y Bioinformática</span>"
    ]
  },
  {
    "objectID": "reintro_a_r.html#conclusión",
    "href": "reintro_a_r.html#conclusión",
    "title": "1  (Re)introducción a R para Biología y Bioinformática",
    "section": "1.8 Conclusión",
    "text": "1.8 Conclusión\nAhora has sido introducido a los conceptos básicos de la programación en R con ejemplos relevantes para la biología y la bioinformática. Hemos cubierto operaciones aritméticas básicas, asignación de variables, tipos de datos, estructuras de datos, graficación simple y una introducción al análisis de redes con igraph. Continúa practicando para familiarizarte más con R y explora temas más avanzados a medida que progresas.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>(Re)introducción a R para Biología y Bioinformática</span>"
    ]
  },
  {
    "objectID": "reintro_a_r.html#recursos-adicionales",
    "href": "reintro_a_r.html#recursos-adicionales",
    "title": "1  (Re)introducción a R para Biología y Bioinformática",
    "section": "1.9 Recursos Adicionales",
    "text": "1.9 Recursos Adicionales\nAquí hay algunos recursos para ayudarte a seguir aprendiendo R y bioinformática: - Documentación de R - Bioconductor - Hojas de Referencia de RStudio",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>(Re)introducción a R para Biología y Bioinformática</span>"
    ]
  },
  {
    "objectID": "hpo_redes1.html",
    "href": "hpo_redes1.html",
    "title": "2  Practica Redes 1: Análisis de redes con R y iGRAPH:",
    "section": "",
    "text": "2.0.1 Objetivos\nEn este tutorial, exploraremos cómo obtener una lista de genes asociados con el fenotipo de morfología anormal del corpúsculo renal de la Ontología de Fenotipos Humanos (HPO). Luego, utilizaremos esta lista de genes para construir una red de interacción genética utilizando STRINGdb en R y la analizaremos con el paquete igraph.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Practica Redes 1: Análisis de redes con R y iGRAPH:</span>"
    ]
  },
  {
    "objectID": "hpo_redes1.html#parte-1-descargar-la-lista-de-genes-de-la-hpo",
    "href": "hpo_redes1.html#parte-1-descargar-la-lista-de-genes-de-la-hpo",
    "title": "2  Practica Redes 1: Análisis de redes con R y iGRAPH:",
    "section": "2.1 Parte 1: Descargar la Lista de Genes de la HPO",
    "text": "2.1 Parte 1: Descargar la Lista de Genes de la HPO\n\n2.1.1 Descarga Manual\n\nNavega al sitio web de la Ontología de Fenotipos Humanos (HPO).\nBusca abnormal renal corpuscle morphology en la barra de búsqueda.\nHaz clic en el fenotipo para ver los detalles.\nLocaliza la lista de genes asociados y descárgala en formato de texto (Export Associations).\n\nANOTA el codigo HPO del fenotipo, nos va a hacer falta para el siguiente paso:\n\n\n2.1.2 Uso de la API\n\n2.1.2.1 ¿Qué es una API?\nUna Interfaz de Programación de Aplicaciones (API) permite que diferentes aplicaciones de software se comuniquen entre sí. En nuestro caso, nos permite acceder programáticamente a datos de la HPO. Puedes usar una API para obtener automáticamente la lista de genes sin tener que descargarla manualmente.\nPara usar la API, aquí hay un ejemplo de cómo obtener genes programáticamente. Primero, necesitamos instalar y cargar las bibliotecas necesarias:\n\n# Install necessary packages if not already installed\nSys.setenv(CURL_SSL_BACKEND = \"openssl\") # Necessary step to reinstall curl for use in Windows\ninstall.packages(\"curl\", force=TRUE, dependencies = TRUE)\n\nif (!requireNamespace(\"httr\", quietly = TRUE)) {\n  install.packages(\"httr\")\n}\nif (!requireNamespace(\"jsonlite\", quietly = TRUE)) {\n  install.packages(\"jsonlite\")\n}\n\nlibrary(httr)\nlibrary(jsonlite)\n\n# API request to get genes associated with the HPO term for abnormal renal corpuscle morphology\nhpo_id &lt;- \"HP:0031263\"  # HPO ID for abnormal renal corpuscle morphology\n\nurl &lt;- paste0(\"https://ontology.jax.org/api/network/annotation/\", hpo_id)\n\nresponse &lt;- GET(url)\ndata &lt;- content(response, as = \"text\", encoding = \"UTF-8\")\ngenes &lt;- fromJSON(data)$genes\n\n# Display the first few genes\nhead(genes)\n\n# Display all the genes\nprint(genes)\n\n\n\n\n2.1.3 Preguntas\n¿Qué función cumple requireNamespace() en el contexto de la instalación de paquetes en R?\nRespuesta: requireNamespace() verifica si un paquete está instalado y disponible para ser utilizado sin cargarlo en el entorno de trabajo. Esto es importante porque permite comprobar la disponibilidad de un paquete antes de intentar usarlo, evitando errores si el paquete no está instalado. Si el paquete no está disponible, se puede instalar automáticamente con install.packages(), asegurando que el código se ejecute sin interrupciones.\nEn la línea url &lt;- paste0(\"https://ontology.jax.org/api/network/annotation/\", hpo_id), ¿qué papel juega paste0() en la construcción de la URL?\nRespuesta: paste0() se utiliza para concatenar cadenas de texto sin ningún separador. En este caso, une la parte estática de la URL con el identificador HPO (hpo_id). Si se utilizara paste() en lugar de paste0(), el resultado podría incluir un espacio adicional, lo que generaría una URL incorrecta. Por ejemplo, paste() usaría un espacio por defecto como separador entre los elementos concatenados, lo que provocaría un error al intentar acceder a la URL.\n¿Cuál es el propósito de las funciones GET() y content() en este código?\nRespuesta: La función GET() realiza una solicitud HTTP para obtener datos de la URL especificada. En este caso, se utiliza para recuperar información sobre genes asociados con un término HPO. La función content() procesa la respuesta de la solicitud, extrayendo el contenido del cuerpo de la respuesta en un formato específico (en este caso, como texto). Después, fromJSON() convierte ese texto JSON en un objeto R que puede manipularse fácilmente. Se espera que el objeto resultante contenga una lista de genes que se pueden utilizar para análisis posteriores.\n¿Cuáles son las ventajas de descargar datos directamente de una API?\nRespuesta: Utilizar una API permite obtener datos de manera automática, lo que puede ahorrar tiempo y reducir errores. Las API también suelen proporcionar datos actualizados y en un formato estructurado, lo que facilita su análisis.\n¿Cuáles podrían ser algunas limitaciones o desafíos de usar una API para la recuperación de datos?\nRespuesta: Algunas limitaciones pueden incluir la necesidad de una conexión a internet, la posibilidad de que la API tenga restricciones de uso o limitaciones en la cantidad de datos que se pueden solicitar a la vez. También puede haber problemas de compatibilidad si los datos devueltos por la API cambian.\n¿Puedes encontrar una función que te diga cuántas filas hay en el objeto genes? ¿Qué representa este número? ¿Cómo se compara con los resultados del web de HPO?\nRespuesta: Para contar cuántas filas hay en el objeto genes, puedes usar la función nrow() en R. Esta función devuelve el número de filas de un marco de datos o de una matriz. Este número representa la cantidad de genes que se han asociado con el fenotipo de interés, en este caso, morfología anormal del corpúsculo renal. Cada fila en el objeto genes corresponde a un gen único relacionado con ese fenotipo. Debe ser igual que el numero encontrado por el Web.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Practica Redes 1: Análisis de redes con R y iGRAPH:</span>"
    ]
  },
  {
    "objectID": "hpo_redes1.html#parte-2-obtención-de-la-red-de-interacción-con-stringdb",
    "href": "hpo_redes1.html#parte-2-obtención-de-la-red-de-interacción-con-stringdb",
    "title": "2  Practica Redes 1: Análisis de redes con R y iGRAPH:",
    "section": "2.2 Parte 2: Obtención de la Red de Interacción con STRINGdb",
    "text": "2.2 Parte 2: Obtención de la Red de Interacción con STRINGdb\nUna vez que hemos obtenido la lista de genes asociados con el fenotipo de morfología anormal del corpúsculo renal, el siguiente paso es explorar cómo estos genes interactúan entre sí. Para ello, utilizaremos la base de datos STRING (Search Tool for the Retrieval of Interacting Genes/Proteins), que proporciona información sobre las interacciones conocidas y pronosticadas entre proteínas y genes. Esta base de datos incluye información sobre interacciones de proteínas a nivel físico, funcional y de co-expresión, lo que es esencial para entender las vías biológicas y las redes de señalización involucradas en diversas condiciones fenotípicas.\nA través de la API de STRING, podemos obtener de manera programática una red de interacción que nos ayudará a visualizar y analizar las relaciones entre los genes de interés. Utilizaremos el paquete STRINGdb en R para acceder a estas interacciones y construir la red que analizaremos posteriormente.\nA continuación, aseguramos de que tienes el paquete STRINGdb instalado y luego procederemos a obtener la red de interacción.\n\nif (!requireNamespace(\"BiocManager\", quietly = TRUE)) {\n  install.packages(\"BiocManager\")\n}\n# Install the STRINGdb package if not already installed\nif (!requireNamespace(\"STRINGdb\", quietly = TRUE)) {\n  BiocManager::install(\"STRINGdb\", ask = FALSE, update = FALSE, type = \"binary\")\n}\n\nlibrary(STRINGdb)\n\n# Initialize STRINGdb with the appropriate version and species\nstring_db &lt;- STRINGdb$new(version = \"12\", species = 9606, score_threshold = 800, input_directory = \"\")\n\n# Fetch interactions for the gene list\n# Replace 'genes' with your actual gene list variable\ngene_ids &lt;- genes$name  # Adjust according to your downloaded data structure\nstring_ids &lt;- string_db$map( genes, \"name\", removeUnmappedRows = TRUE )\n\ninteraction_network &lt;- string_db$get_interactions(string_ids$STRING_id)\ninteraction_network &lt;- unique(interaction_network[, 1:2]) # necessary step to remove duplicate interactions\ninteraction_network$to &lt;- string_ids$name[match(interaction_network$to, string_ids$STRING_id)]\ninteraction_network$from &lt;- string_ids$name[match(interaction_network$from, string_ids$STRING_id)]\n\n# Display the first few rows of the interaction network\nhead(interaction_network)\n\n\n2.2.1 Preguntas\n¿Qué significa la línea string_db &lt;- STRINGdb$new(version = \"12\", species = 9606, score_threshold = 400, input_directory = \"\")?\nRespuesta: Esta línea inicializa un nuevo objeto STRINGdb, configurando la versión de la base de datos a utilizar (en este caso, la versión 12), especificando el organismo (especie humana, cuyo código es 9606) y estableciendo un umbral de puntuación de 400 para las interacciones que se consideran relevantes. El parámetro input_directory se deja vacío porque no se están usando archivos de entrada locales.\n¿Cuál es el propósito de la línea string_ids &lt;- string_db$mp(gene_ids)?\nRespuesta: La función mp() convierte los identificadores de genes (en este caso, almacenados en gene_ids) a los identificadores de STRING. Esto es necesario porque los genes pueden tener diferentes identificadores en diferentes bases de datos, y mp() asegura que se utilicen los correctos en la base de datos STRING.\n¿Por qué es importante establecer un score_threshold al inicializar STRINGdb?\nRespuesta: El score_threshold define el umbral mínimo de puntuación para las interacciones que se incluirán en la red. Interacciones con puntuaciones por debajo de este umbral serán excluidas, lo que ayuda a centrarse en las interacciones más relevantes y significativas y a reducir el ruido en los datos.\n¿Cuántas filas hay en el objeto interaction_network? ¿Qué representa este número? ¿Qué pasaría si repetimos el ejercicio aumentando el score_threshold?\nRespuesta: Este número representa la cantidad de interacciones que se han obtenido entre los genes de la red. Cada fila en el objeto interaction_network corresponde a una interacción única entre dos genes, donde se especifican detalles sobre la relación entre ellos. Si aumentamos el score_threshold, la red resultante seria mas pequeño.\n\n\n2.2.2 Explicación Adicional\nEn las redes biológicas, a menudo se utilizan redes no dirigidas porque la interacción entre genes no tiene una dirección específica, reflejando interacciones mutuas en lugar de influencias unidireccionales.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Practica Redes 1: Análisis de redes con R y iGRAPH:</span>"
    ]
  },
  {
    "objectID": "hpo_redes1.html#parte-3-conversión-a-formato-igraph-y-calculos-de-propiedades-de-una-red",
    "href": "hpo_redes1.html#parte-3-conversión-a-formato-igraph-y-calculos-de-propiedades-de-una-red",
    "title": "2  Practica Redes 1: Análisis de redes con R y iGRAPH:",
    "section": "2.3 Parte 3: Conversión a Formato igraph y calculos de propiedades de una red",
    "text": "2.3 Parte 3: Conversión a Formato igraph y calculos de propiedades de una red\nEn esta sección, convertiremos la red de interacción obtenida de STRINGdb al formato igraph. igraph es un paquete en R que proporciona herramientas para crear, manipular y analizar redes. Nos centraremos en calcular propiedades clave de la red que nos ayudarán a entender mejor su estructura.\nPrimero, asegúrate de tener instalado y cargado el paquete igraph:\n\n# Install igraph if it's not already installed\nif (!requireNamespace(\"igraph\", quietly = TRUE)) {\n  install.packages(\"igraph\")\n}\n\nlibrary(igraph)\n\n\n2.3.1 Conversión a Formato igraph\nPara convertir la red de interacción que hemos obtenido de STRINGdb a un objeto igraph, utilizaremos la función graph_from_data_frame(), que permite crear una red a partir de un data frame que contiene las interacciones.\nAsumamos que interaction_network tiene al menos dos columnas: gene1 y gene2, que representan los nodos conectados. La conversión se realiza de la siguiente manera:\n\n# Convert the interaction network downloaded from STRING into igraph format\ng &lt;- graph_from_data_frame(interaction_network, directed = FALSE)\n\n\n\n2.3.2 Cálculo de Propiedades de la Red\nUna vez que tenemos nuestra red en formato igraph, podemos calcular diversas propiedades que nos brindan información sobre su estructura y características. A continuación, se presentan algunas propiedades importantes que puedes calcular:\n\n2.3.2.1 Número de Nodos y Aristas\nPodemos calcular el número total de nodos y aristas en la red utilizando las funciones gorder() y gsize():\n\n# Calculate numbers of nodes and edges\nnum_nodes &lt;- gorder(g)  # Number of nodes\nnum_edges &lt;- gsize(g)  # Number of edges\n\ncat(\"Number of nodes:\", num_nodes, \"\\n\")\ncat(\"Number of edges:\", num_edges, \"\\n\")\n\n\n\n2.3.2.2 Grado Promedio de los Nodos\nEl grado de un nodo es el número de conexiones que tiene. Podemos calcular el grado promedio de todos los nodos en la red:\n\n# Calculate the degree (grado) of every node\ndegree_values &lt;- degree(g)\n\n# Calculate the average\naverage_degree &lt;- mean(degree_values)\ncat(\"Average degree of all nodes:\", average_degree, \"\\n\")\n\n\n\n2.3.2.3 Densidad de la Red\nLa densidad de una red es una medida que indica qué tan conectados están los nodos entre sí. Se calcula como el número de aristas dividido por el número máximo posible de aristas:\n\n# Calculate the density of the network\nnetwork_density &lt;- edge_density(g)\ncat(\"Network density:\", network_density, \"\\n\")\n\n\n\n2.3.2.4 Centralidad\nLa centralidad nos ayuda a identificar los nodos más importantes dentro de la red. Podemos calcular diferentes medidas de centralidad, aqui vemos centralidad de cercanía:\n\n# Calculate Closeness Centrality (centralidad de cercanía)\ncentrality_closeness &lt;- closeness(g)\n\n# Show results\ncat(\"Closeness Centrality (first 5 nodos):\", head(centrality_closeness, 5), \"\\n\")\n\n\n\n\n2.3.3 Preguntas\nDespués de calcular estas propiedades, reflexiona sobre las siguientes preguntas:\n¿Cuál es la importancia de crear una red no dirigido en el contexto de las interacciones génicas? Como hemos creado una red no dirigida?\nEn las redes biológicas, a menudo se utilizan redes no dirigidos porque la interacción entre genes no tiene una dirección específica, reflejando interacciones mutuas en lugar de influencias unidireccionales.\n¿Qué información proporcionan estas métricas sobre la red de interacción de genes?\nEl número de nodos y aristas nos muestra cuántos genes y cuántas interacciones hay en la red, proporcionando una idea de su complejidad. El grado promedio indica cuántas conexiones tiene cada gen en promedio, lo que refleja cuán interconectados están los genes. La densidad nos informa sobre la proporción de conexiones posibles que realmente ocurren, y la centralidad identifica genes clave que podrían desempeñar roles críticos en la red\n¿Hay nodos que se destacan por su grado o centralidad? ¿Cómo podría esto estar relacionado con sus funciones biológicas?\nLos nodos con mayor grado o centralidad suelen ser hubs dentro de la red, lo que significa que están muy conectados o son esenciales para la transmisión de información. En un contexto biológico, estos genes pueden estar implicados en funciones importantes o regulando varias vías. Si estos genes clave están relacionados con la morfología anormal del corpúsculo renal, podrían ser cruciales para entender las bases moleculares de esta enfermedad.\n¿Qué implicaciones podrían tener estas propiedades para entender la morfología anormal del corpúsculo renal?\nEl análisis de estas propiedades te ayudará a desarrollar una comprensión más profunda de las interacciones en la red y su relevancia en contextos biológicos.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Practica Redes 1: Análisis de redes con R y iGRAPH:</span>"
    ]
  },
  {
    "objectID": "hpo_redes1.html#parte-4-visualizando-la-red",
    "href": "hpo_redes1.html#parte-4-visualizando-la-red",
    "title": "2  Practica Redes 1: Análisis de redes con R y iGRAPH:",
    "section": "2.4 Parte 4: Visualizando la Red",
    "text": "2.4 Parte 4: Visualizando la Red\nUna vez que tenemos nuestra red en formato igraph, podemos proceder a realizar diversas visualizaciones y análisis estadísticos. La visualización es una parte crucial del análisis de redes, ya que nos ayuda a entender la distribución y la relación entre los diferentes nodos.\nEn esta sección, utilizaremos funciones del paquete igraph para crear gráficos visualmente informativos que representen las interacciones entre genes. Además, calcularemos estadísticas de la red, como el número de nodos e interacciones, lo que nos permitirá obtener una visión general de la complejidad y la conectividad de nuestra red. Esto es especialmente relevante en biología molecular, donde las interacciones entre genes pueden proporcionar información valiosa sobre funciones biológicas y mecanismos de enfermedades.\n\n2.4.1 Gráfico Básico\n\n# Basic plot of the network\nplot(g, vertex.size=5, vertex.label.cex=0.7, edge.arrow.size=0.5,  main=\"Basic Interaction Network\")\n\n\n\n2.4.2 Visualizaciones Personalizadas\n\n2.4.2.1 Graficado en base a atributo de nodo\n\n# Basic plot of the network\nplot(g, vertex.size=degree(g)/2, edge.arrow.size=0.7, vertex.label.cex=0.8, main=\"Network by degree\")\n\n\n\n2.4.2.2 Disposición de Fruchterman-Reingold\n\nlayout &lt;- layout_with_fr(g)  # Fruchterman-Reingold layout\nplot(g, layout = layout, vertex.color = \"skyblue\", vertex.size = 5, edge.width = 0.5, main = \"Fruchterman-Reingold Layout\")\n\n\n\n2.4.2.3 Disposición Circular\n\n# Help page access\n?layout_in_circle  # Recuerda cómo acceder a las páginas de ayuda\n\n# Plot with circular layout\ncircular_layout &lt;- layout_in_circle(g)\nplot(g, layout = circular_layout, vertex.color = \"lightgreen\", vertex.size = 5, vertex.label.cex=0.8,edge.width = 0.5, main = \"Circular Layout\")\n\n\n\n2.4.2.4 Disposición “nice”\n\n# Plot with nicely layout\nnice_layout &lt;- layout_nicely(g)\nplot(g, layout = nice_layout, vertex.color = \"orange\", vertex.size = 5,vertex.label.cex=0.8, edge.width = 0.5, main = \"Nicely Layout\")\n\n\n\n\n2.4.3 Preguntas\n¿Qué observas sobre la estructura de la red en diferentes disposiciones? ¿Hay áreas densamente conectadas?\nAl observar la estructura de la red en diferentes disposiciones, es posible notar que la disposición afecta la manera en que percibimos la organización de los nodos y las conexiones. En algunas disposiciones, como la disposición en círculo o en rejilla, la estructura general es más clara, pero puede ser difícil identificar áreas con conexiones densas. En cambio, otras \"visualizations\" tienden a agrupar de manera más natural los nodos más conectados, haciendo que las áreas densamente conectadas se resalten visualmente. Estas áreas densas, conocidas como clusters, suelen estar formadas por grupos de genes que interactúan de manera más fuerte entre sí, lo que podría indicar que participan en procesos biológicos similares o relacionados.\n¿Puedes identificar algunos modulos en la red? ¿Cuál podría ser su significado biológico?\nSí, es posible identificar agrupaciones claras en la red, conocidas como clusters o módulos, que suelen estar formadas por nodos (genes) que están densamente interconectados entre sí. Estas agrupaciones pueden reflejar grupos de genes que participan en funciones biológicas comunes, como rutas metabólicas, procesos celulares específicos o complejos proteicos. Veremos mas sobre como identificar estos grupos la semana que viene.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Practica Redes 1: Análisis de redes con R y iGRAPH:</span>"
    ]
  },
  {
    "objectID": "hpo_redes2.html",
    "href": "hpo_redes2.html",
    "title": "3  Práctica Redes 2: Clusterizacion y Enriquecimiento Funcional",
    "section": "",
    "text": "3.1 Parte 1: Regenerando la Red de Interacción (Recordatorio)\nEn este práctico, nos enfocaremos en regenerar la red de interacción genética de la semana pasada utilizando STRINGdb. Luego, aplicaremos algoritmos de clustering para identificar grupos de genes altamente conectados. Posteriormente, realizaremos un análisis de sobre-representación utilizando clusterProfiler para interpretar los posibles roles biológicos de estas comunidades. Finalmente, visualizaremos los resultados de enriquecimiento de manera clara y efectiva. Usaremos los genes asociados al fenotipo de morfología anormal del corpúsculo renal que obtuvimos en la práctica anterior.\nEn esta sección, recordaremos cómo construir una red de interacción utilizando STRINGdb y convertirla a un formato que podamos usar con la librería igraph en R.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Práctica Redes 2: Clusterizacion y Enriquecimiento Funcional</span>"
    ]
  },
  {
    "objectID": "hpo_redes2.html#parte-1-regenerando-la-red-de-interacción-recordatorio",
    "href": "hpo_redes2.html#parte-1-regenerando-la-red-de-interacción-recordatorio",
    "title": "3  Práctica Redes 2: Clusterizacion y Enriquecimiento Funcional",
    "section": "",
    "text": "3.1.1 ¿Qué es STRINGdb?\nSTRINGdb es una base de datos que proporciona información sobre interacciones entre proteínas y genes, así como las evidencias que respaldan estas interacciones. Utiliza datos de diversas fuentes, incluyendo experimentos de laboratorio, datos de literatura y predicciones computacionales.\n\n# Load required packages\nSys.setenv(CURL_SSL_BACKEND = \"openssl\") # Necessary step to reinstall curl for use in Windows\ninstall.packages(\"curl\", force=TRUE, dependencies = TRUE)\n\nif (!requireNamespace(\"httr\", quietly = TRUE)) install.packages(\"httr\")\nif (!requireNamespace(\"jsonlite\", quietly = TRUE)) install.packages(\"jsonlite\")\nif (!requireNamespace(\"BiocManager\", quietly = TRUE)) install.packages(\"BiocManager\")\nif (!requireNamespace(\"STRINGdb\", quietly = TRUE)) {\n  BiocManager::install(\"STRINGdb\", ask = FALSE, update = FALSE, type = \"binary\")\n}\nif (!requireNamespace(\"igraph\", quietly = TRUE)) install.packages(\"igraph\")\n\nlibrary(httr)\nlibrary(jsonlite)\nlibrary(igraph)\nlibrary(STRINGdb)\n\n# API request to get genes associated with the HPO term for abnormal renal corpuscle morphology\nhpo_id &lt;- \"HP:0031263\"  # HPO ID for abnormal renal corpuscle morphology\nurl &lt;- paste0(\"https://ontology.jax.org/api/network/annotation/\", hpo_id)\nresponse &lt;- GET(url)\ndata &lt;- content(response, as = \"text\", encoding = \"UTF-8\")\ngenes &lt;- fromJSON(data)$genes\n\n# Initialize STRINGdb\n# Can you see anything different here compared to the last practical?\nstring_db &lt;- STRINGdb$new(version = \"12\", species = 9606, score_threshold = 400, input_directory = \"\")\nstring_ids &lt;- string_db$map( genes, \"name\", removeUnmappedRows = TRUE )\n\ninteraction_network &lt;- string_db$get_interactions(string_ids$STRING_id)\ninteraction_network &lt;- unique(interaction_network[, 1:2]) # necessary step to remove duplicate interactions\ninteraction_network$to &lt;- string_ids$name[match(interaction_network$to, string_ids$STRING_id)]\ninteraction_network$from &lt;- string_ids$name[match(interaction_network$from, string_ids$STRING_id)]\n\n# How can I see how big the network is? How does it compare to last week?\n\n\n\n3.1.2 Preguntas de Reflexión (recordatorios)\n¿Qué tipo de información proporciona STRINGdb sobre las interacciones entre genes?\nSTRINGdb proporciona una amplia gama de información sobre las interacciones entre genes y proteínas. Esto incluye interacciones físicas directas, como enlaces proteicos, e interacciones funcionales, donde las proteínas pueden estar involucradas en los mismos procesos biológicos sin interactuar físicamente. Las interacciones están respaldadas por diferentes tipos de evidencias, como datos experimentales, coexpresión, similitud de dominios, y estudios computacionales. Además, STRINGdb asigna una puntuación de confianza (confidence score) a cada interacción, lo que ayuda a evaluar la fiabilidad de la conexión entre los genes o proteínas en la red.\n¿Por qué es importante establecer un umbral de puntuación (score_threshold) al obtener interacciones?\nEl umbral de puntuación (score_threshold) es crucial porque permite filtrar las interacciones según su grado de confianza o fiabilidad. STRINGdb asigna un score a cada interacción basado en la calidad y cantidad de evidencia que respalda la relación entre los genes o proteínas. Un valor más alto indica una mayor confianza en la interacción. Al ajustar el umbral, se puede obtener una red más robusta y precisa, eliminando interacciones que podrían ser falsas o de baja confianza. Si el umbral es muy bajo, podrías obtener demasiadas interacciones espureas; si es demasiado alto, podrías perder conexiones importantes pero menos documentadas.\n¿Cómo se relacionan las interacciones en la red con las funciones biológicas de los genes involucrados?\nLas interacciones en la red pueden proporcionar información clave sobre las funciones biológicas de los genes involucrados. Genes que estén conectados en una red suelen participar en procesos biológicos relacionados, como rutas metabólicas, señalización celular, o respuestas a estímulos. Las redes permiten identificar módulos o agrupaciones de genes que trabajan juntos, lo cual puede revelar nuevas funciones biológicas o ayudar a comprender mejor las rutas moleculares en las que participan. Al analizar estas interacciones, los investigadores pueden inferir funciones desconocidas para algunos genes basándose en los genes con los que están conectados en la red, un concepto conocido como \"guilt by association\".",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Práctica Redes 2: Clusterizacion y Enriquecimiento Funcional</span>"
    ]
  },
  {
    "objectID": "hpo_redes2.html#parte-2-clustering-de-la-red-con-igraph",
    "href": "hpo_redes2.html#parte-2-clustering-de-la-red-con-igraph",
    "title": "3  Práctica Redes 2: Clusterizacion y Enriquecimiento Funcional",
    "section": "3.2 Parte 2: Clustering de la Red con igraph",
    "text": "3.2 Parte 2: Clustering de la Red con igraph\n\n3.2.1 ¿Qué es el clustering?\nEl clustering en redes es el proceso de identificar grupos de nodos (genes, en este caso) que están más densamente conectados entre sí que con otros nodos de la red. Este enfoque permite detectar módulos o clusters, que pueden representar vías de señalización o grupos funcionales de genes que operan juntos.\n\n\n3.2.2 Teoría Detrás del Clustering\n\n3.2.2.1 Conceptos Fundamentales\n\nTeoría de Grafos: En el contexto de las redes, los grafos se componen de nodos (genes) y aristas (interacciones).\nCentralidad (Centrality): La centralidad mide la importancia de un nodo dentro de la red. Hay varias formas de calcular la centralidad:\n\nCentralidad de Grado (Degree Centrality): Número de conexiones que tiene un nodo. Un alto grado puede indicar un nodo clave en la red.\nCentralidad de Intermediación (Betweenness Centrality): Indica cuántas veces un nodo actúa como un puente a lo largo de los caminos más cortos entre otros nodos. Los nodos con alta centralidad de intermediación pueden controlar la comunicación en la red.\nCentralidad de Cercanía (Closeness Centrality): Mide qué tan cerca está un nodo de todos los demás nodos en la red, lo que puede reflejar su capacidad para acceder rápidamente a información.\n\nDensidad (Network Density): Se refiere a la proporción de conexiones existentes en la red en comparación con el número máximo posible de conexiones. Una red densa puede indicar una alta interconexión entre nodos, lo cual es fundamental para la identificación de clusters.\nModularidad (Modularity): La modularidad es una medida de la estructura de la red que indica la calidad de la división en módulos o clusters. Un clustering con alta modularidad tiene muchas conexiones dentro de los clusters y pocas entre ellos. La optimización de la modularidad es un objetivo común en muchos algoritmos de clustering.\nCaminos y Conectividad (Paths and Connectivity): La existencia de caminos cortos y la conectividad entre nodos son cruciales para el clustering. Los clusters suelen tener caminos más cortos entre sus nodos que con nodos externos, lo que refleja su cohesión.\n\n\n\n3.2.2.2 Visualizando los conceptos\nPara ilustrar estos conceptos, utilizaremos la función `sample_islands de igraph para crear un grafo sintético compuesto por “islas” o clústeres densamente conectados y parcialmente aislados. Este tipo de red es ideal para demostrar varios principios importantes de la teoría de grafos y el análisis de redes, incluyendo centralidad, modularidad, densidad y conectividad. A continuación, se explica cómo se relaciona con cada uno de estos principios:\n\n# Load required packages\nlibrary(igraph)\n# Create a network to illustrate important principles\ng &lt;- sample_islands(3, 30, 0.9, 10)\n\n# Visualize the graph\nplot(g, vertex.size=5, vertex.label=NA, edge.arrow.size=0.2, main=\"Red de islas para mostrar propiedades relacionadas con el clustering\")\n\n\n\n3.2.2.3 Cómo la Red de Sample_Islands Demuestra Estos Principios:\n\nIntra-isla: Los nodos dentro de las islas están densamente conectados, mostrando una alta densidad local, caminos cortos y alta modularidad dentro de los clústeres. Estos nodos tienen una centralidad de grado y cercanía alta en relación con su propia isla.\nInter-isla: Los nodos que conectan diferentes islas poseen una alta centralidad de intermediación, ya que funcionan como puentes entre diferentes comunidades. Estos nodos controlan el flujo de información a través de la red.\nLa escasez de conexiones entre islas demuestra cómo una baja densidad global y caminos más largos entre clústeres crean clústeres bien separados, ideales para agrupamiento basado en modularidad.\n\n\n\n3.2.2.4 Generación de una Red tipo Erdős-Rényi\nAhora veremos otros tipos de grafos importantes en teoría de redes y biología de sistemas. Los grafos de Erdős-Rényi, propuestos por Paul Erdős y Alfréd Rényi en los años 50, fueron el primer modelo formal de redes aleatorias. Conectan pares de nodos al azar con una probabilidad fija.\n\nset.seed(123)\ng &lt;- sample_gnp(50, p=0.05)\n\n# Visualize the network\nset.seed(123)\nplot(g, vertex.size=5, vertex.label=NA, edge.arrow.size=0.2, main=\"Erdős-Rényi network\")\n\n\n\n3.2.2.5 Generación de una Red con Estructura Core-Periphery\nVamos a generar una red que simule una estructura core-periphery usando la librería igraph. Esta estructura nos permitirá ver cómo los diferentes algoritmos de clustering lidian con un núcleo denso de nodos interconectados y una periferia menos conectada.\n\n# Generate a core-periphery network\nset.seed(123)\ng &lt;- sample_gnp(50, 0.05)  # Periphery: sparse network\ncore_nodes &lt;- sample(1:vcount(g), 10)  # Select core nodes\ng &lt;- add_edges(g, combn(core_nodes, 2))  # Add dense connections in the core\nV(g)$color &lt;- ifelse(1:vcount(g) %in% core_nodes, \"red\", \"blue\")  # Color nodes based on core or periphery\n\n# Visualize the network\nset.seed(123)\nplot(g, vertex.size=5, vertex.label=NA, edge.arrow.size=0.2, main=\"Core-periphery network\")\n\nEn esta red, los nodos rojos representan el núcleo, un grupo densamente interconectado, mientras que los nodos azules representan la periferia, que tiene conexiones más dispersas. Esta estructura simula la organización biológica donde un grupo central de genes podría estar estrechamente vinculado funcionalmente, mientras que los genes periféricos podrían estar involucrados en funciones más especializadas o de soporte.\n\n\n3.2.2.6 Generación de una Red tipo Barabási–Albert\nVamos a generar una red que simule una red de tipo libre de escala. Esto es un modelo de red basado en “rich get richer” o de ventaja acumulativa. Los nodos con mayor grado tienen mayor probabilidad de generar nuevas conexiones que los de menor grado. La distribución del grado de los nodos sigue una ley de potencial.\n\n# Generate a core-periphery network\nset.seed(123)\ng_ba &lt;- sample_pa(100, power = 1.9, directed = FALSE)\nplot(g_ba, vertex.size=5, vertex.label=NA, edge.arrow.size=0.2, main=\"Barabasi–Albert network\")\n\n\n\n\n3.2.3 Distintos algoritmos para clusterizar una red\n\nAlgoritmo de Louvain\n\nEl algoritmo de Louvain optimiza la modularidad, agrupando nodos de manera que se maximicen las conexiones dentro de los clusters y se minimicen entre clusters. Este algoritmo es eficiente para redes grandes y suele identificar grandes clusters en el núcleo.\n\n# Clustering using the Louvain algorithm\ncluster_louvain &lt;- cluster_louvain(g)\nset.seed(123)\nplot(cluster_louvain, g, vertex.size=5, vertex.label=NA, edge.arrow.size=0.2, main=\"Clustering with Louvain\")\n\n\nObservación: En redes core-periphery, Louvain puede identificar el núcleo como un único cluster grande, mientras que los nodos periféricos pueden agruparse en pequeños clusters dispersos.\nEnfoque tipo agregativo no jerárquico.\n\n\nAlgoritmo de Girvan-Newman\n\nEl algoritmo de Girvan-Newman se basa en la eliminación de aristas con alta centralidad de intermediación. Al eliminar las conexiones clave (de alta centralidad de intermediación), divide la red en clusters más pequeños, lo que puede descomponer el núcleo en subclusters.Posee alto coste computacional, así que es mejor sólo para redes medianas o pequeñas.\n\nEnfoque jerárquico y divisivo.\n\n\n# Clustering using the Girvan-Newman algorithm\ncluster_girvan_newman &lt;- cluster_edge_betweenness(g)\nset.seed(123)\nplot(cluster_girvan_newman, g, vertex.size=5, vertex.label=NA, edge.arrow.size=0.2, main=\"Clustering with Girvan-Newman\")\n\n\nAlgoritmo de Infomap El algoritmo Infomap utiliza flujos de información para identificar clusters en la red. Al modelar cómo se transmite la información entre los nodos, Infomap puede identificar tanto clusters en el núcleo como en la periferia. De gran escalabilidad para redes grandes.\n\n\n# Clustering using the Infomap algorithm\ncluster_infomap &lt;- cluster_infomap(g)\nset.seed(123)\nplot(cluster_infomap, g, vertex.size=5, vertex.label=NA, edge.arrow.size=0.2, main=\"Clustering with Infomap\")\n\n\nObservación: Infomap es particularmente útil para identificar subestructuras ocultas dentro de redes complejas como las de core-periphery, donde el flujo de información entre nodos puede revelar clusters que otros algoritmos pasan por alto.\n\nReflexión sobre los Resultados Cada uno de estos algoritmos ofrece una interpretación diferente de la red con estructura core-periphery. Por ejemplo:\n\nLouvain tiende a identificar grandes clusters, pero puede pasar por alto subestructuras dentro del núcleo.\nGirvan-Newman es capaz de obtener clusters menores.\nInfomap ofrece una visión única basada en los flujos de información a través de la red, detectando clusters tanto en el núcleo como en la periferia.\n\nEl clustering en redes biológicas es una herramienta poderosa para identificar módulos funcionales y estructuras subyacentes. Sin embargo, como hemos visto con la red core-periphery, no existe un único algoritmo que funcione para todas las redes. Cada uno tiene sus ventajas y limitaciones, y la elección del algoritmo adecuado depende de la naturaleza de la red y de los objetivos del análisis.\n\n3.2.3.1 Preguntas\n¿Por qué es importante considerar la centralidad de intermediación (betweenness centrality) cuando analizamos redes biológicas?\nLa centralidad de intermediación indica cuántas veces un nodo actúa como un puente entre otros nodos a lo largo de los caminos más cortos. En redes biológicas, esto puede representar genes o proteínas clave que controlan la comunicación entre distintos módulos funcionales. Los nodos con alta centralidad de intermediación son esenciales para mantener la conectividad global de la red, y su eliminación podría fragmentar la red y aislar módulos, lo que puede tener implicaciones biológicas críticas.\n¿Qué diferencia hay entre la modularidad alta y baja en el clustering de redes, y cómo afecta la interpretación de los clusters?\nUna modularidad alta indica que los nodos dentro de un cluster están muy interconectados, y hay pocas conexiones con nodos fuera del cluster. Esto sugiere que el cluster representa un grupo funcional cohesivo. Por el contrario, una modularidad baja sugiere que los clusters no están bien definidos, con muchas conexiones externas, lo que dificulta la interpretación biológica. Los clusters con alta modularidad suelen corresponder a módulos funcionales claros, mientras que una baja modularidad puede reflejar procesos difusos o redes ruidosas.\n¿Qué ventajas ofrece set.seed() cuando se trabaja con redes aleatorias o algoritmos estocásticos en el análisis de redes, y en qué situaciones sería más útil?\nEl uso de set.seed() permite que los resultados de procesos aleatorios sean reproducibles. En el análisis de redes, donde a menudo se utilizan grafos aleatorios o algoritmos estocásticos, fijar una semilla garantiza que la misma red o resultado se obtenga en cada ejecución del código. Esto es especialmente útil cuando se documentan los resultados o cuando se quiere comparar entre diferentes configuraciones o pruebas. En situaciones de enseñanza o investigación, permite que todos los involucrados trabajen con la misma estructura de red, facilitando la comprensión y el análisis.\n\n\n\n3.2.4 Aplicando algoritmos a nuestra red\nCrea un nuevo bloque en tus documentos Rmd y escribe el código para aplicar los tres algoritmos de agrupamiento a la red de interacción que creamos al inicio de esta práctica. Es posible que necesites consultar tus notas de la práctica anterior para crear un objeto igraph a partir de un data.frame.\n\n\n\n\n\n\nCaution\n\n\n\n\n\n\ng &lt;- graph_from_data_frame(interaction_network, directed = FALSE)\n\ncluster_louvain &lt;- cluster_louvain(g)\nset.seed(123)\nplot(cluster_louvain, g, vertex.size=5, vertex.label=NA, edge.arrow.size=0.2, main=\"Clustering with Louvain\")\n\ncluster_girvan_newman &lt;- cluster_edge_betweenness(g)\nset.seed(123)\nplot(cluster_girvan_newman, g, vertex.size=5, vertex.label=NA, edge.arrow.size=0.2, main=\"Clustering with Girvan-Newman\")\n\ncluster_infomap &lt;- cluster_infomap(g)\nset.seed(123)\nplot(cluster_infomap, g, vertex.size=5, vertex.label=NA, edge.arrow.size=0.2, main=\"Clustering with Infomap\")",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Práctica Redes 2: Clusterizacion y Enriquecimiento Funcional</span>"
    ]
  },
  {
    "objectID": "hpo_redes2.html#functional-enrichment",
    "href": "hpo_redes2.html#functional-enrichment",
    "title": "3  Práctica Redes 2: Clusterizacion y Enriquecimiento Funcional",
    "section": "3.3 Functional Enrichment",
    "text": "3.3 Functional Enrichment\n\n3.3.1 Introducción al Análisis de Enriquecimiento Funcional\nEl análisis de enriquecimiento funcional es un conjunto de técnicas bioinformáticas diseñadas para identificar características funcionales, rutas o procesos biológicos que están representados en exceso dentro de un conjunto de genes de interés. Estas técnicas son fundamentales para ayudar a los investigadores a interpretar grandes cantidades de datos genómicos y transcriptómicos al descubrir las funciones moleculares y procesos biológicos que son importantes en condiciones experimentales específicas, como enfermedades o tratamientos.\nCuando se estudia un conjunto de genes, ya sea obtenido a partir de datos de expresión diferencial, variantes genéticas, o cualquier otra fuente, el análisis de enriquecimiento nos permite responder preguntas como: ¿Qué procesos biológicos están sobrerrepresentados en este conjunto de genes? o ¿Qué funciones moleculares pueden estar relacionadas con el fenotipo de interés?\n\n3.3.1.1 Tipos de Análisis de Enriquecimiento\nExisten diferentes enfoques para el análisis de enriquecimiento, cada uno de los cuales responde a distintas preguntas de investigación y métodos estadísticos. Los más comunes incluyen:\n\nAnálisis de Sobrerrepresentación (Over-Representation Analysis, ORA):\n\nPropósito: Determinar si ciertas funciones biológicas (por ejemplo, términos de Gene Ontology (GO), rutas de KEGG) están sobrerrepresentadas en un conjunto de genes de interés en comparación con un conjunto de fondo o referencia. Método: Se utiliza una prueba estadística (como la prueba exacta de Fisher) para evaluar si la frecuencia observada de un término es mayor de lo esperado al azar en el conjunto de interés.\n\nAnálisis de Enriquecimiento Basado en Rango (Gene Set Enrichment Analysis, GSEA):\n\nPropósito: Identificar conjuntos de genes que muestran una tendencia a ubicarse en las posiciones más altas o bajas en una lista ordenada de acuerdo a una variable continua, como el nivel de expresión. Método: En lugar de seleccionar un subconjunto específico de genes, GSEA evalúa el enriquecimiento en función de la posición en una lista clasificada, eliminando la necesidad de un umbral de significancia arbitrario.\nSelección del Método de Enriquecimiento\nCada método tiene sus ventajas y limitaciones. El ORA es útil cuando ya se ha definido un conjunto específico de genes de interés, mientras que GSEA es particularmente valioso en análisis exploratorios donde no se requiere un corte específico de significancia para definir los genes de interés. Elegir entre estos métodos depende del diseño del experimento y de la naturaleza de los datos.\n\n\n\n3.3.2 Enfoque Práctico: Análisis de Sobrerrepresentación (ORA)\nEn esta práctica, aplicaremos el enfoque de Análisis de Sobrerrepresentación (ORA) para explorar la representación de términos de Gene Ontology (GO) y rutas moleculares en un conjunto específico de genes de interés. Optamos por ORA en lugar de otros métodos como el Análisis de Enriquecimiento Basado en Rango (GSEA) porque en este caso disponemos de un conjunto bien definido de genes, asociados con el fenotipo de “Morfología Anormal del Corpúsculo Renal” en el Human Phenotype Ontology (HPO). Para aplicar GSEA, se requiere una lista completa de genes clasificados y un puntaje asociado a cada gen, lo cual no es aplicable en este escenario.\nCon ORA, podremos determinar si ciertos procesos biológicos o rutas están sobrerrepresentados en este conjunto específico de genes en comparación con un fondo de referencia. Utilizaremos el paquete clusterProfiler en R para realizar este análisis y visualizar los resultados, descubriendo los procesos biológicos relevantes que podrían estar implicados en la estructura y función del corpúsculo renal en condiciones anormales.\n\n3.3.2.1 Teoría del Análisis de Sobrerrepresentación (Over-Representation Analysis, ORA)\nAnálisis de Sobrerrepresentación (ORA) es una técnica estadística que se utiliza para determinar si ciertos términos funcionales (por ejemplo, categorías de Gene Ontology (GO) o rutas de KEGG) están sobrerrepresentados en un conjunto de genes de interés en comparación con un conjunto de genes de fondo. Este tipo de análisis se usa comúnmente para identificar procesos biológicos o rutas moleculares relevantes a partir de datos de expresión diferencial, redes génicas, o cualquier otro conjunto de genes.\n\n\n3.3.2.2 Conceptos Básicos del ORA\n\nConjunto de Genes de Interés: Este conjunto contiene los genes seleccionados para el análisis. En el contexto de una enfermedad o condición, puede incluir genes diferencialmente expresados o genes relacionados con un fenotipo específico.\nConjunto de Fondo (Background): Para comparar la frecuencia de los términos en el conjunto de interés, necesitamos definir un grupo de genes de referencia o fondo, que suele ser el conjunto de todos los genes expresados en el experimento o todos los genes de un organismo.\nPruebas Estadísticas: ORA generalmente utiliza pruebas estadísticas como la prueba exacta de Fisher o la prueba de Chi-cuadrado para determinar si la frecuencia de un término funcional es mayor de lo esperado al azar en el conjunto de interés. La prueba estadística proporciona un valor de p, que puede ajustarse para el control de descubrimientos falsos.\nPasos para Realizar un ORA\n\nDefinir el conjunto de genes de interés y el conjunto de fondo.\nMapear los genes a términos funcionales (por ejemplo, a términos de GO o rutas de KEGG).\nCalcular la frecuencia de cada término en ambos conjuntos y aplicar una prueba estadística para evaluar la significancia.\nInterpretar los resultados, teniendo en cuenta el contexto biológico y el ajuste de p-valores.\n\n\n\n\n\n3.3.3 ORA aplicado a Genes Asociados con el Término HPO “Morfología Anormal del Corpúsculo Renal”\nVamos a realizar un análisis ORA usando el paquete clusterProfiler en R. Para ilustrar el procedimiento, consideraremos genes asociados con el término del Human Phenotype Ontology (HPO) “Morfología Anormal del Corpúsculo Renal” (abnormal renal corpuscle morphology). Este análisis identificará procesos o rutas biológicas que están sobrerrepresentados en este grupo de genes.\nclusterProfiler ofrece la función enrichGO para realizar el análisis de enriquecimiento basado en términos de GO. Vamos a ejecutarlo sobre nuestros genes de interés.\n\nBiocManager::install(\"GenomeInfoDb\")\nBiocManager::install(\"org.Hs.eg.db\", ask = FALSE, update = FALSE)\nBiocManager::install(\"GO.db\", ask = FALSE, update = FALSE)\nBiocManager::install(\"clusterProfiler\", ask = FALSE, update = FALSE, type = \"binary\")\n\nlibrary(clusterProfiler)\nlibrary(org.Hs.eg.db) # Base de datos de genes humanos\n\n# Execute ORA enrichment analysis\nenrich_results &lt;- enrichGO(\n  gene          = genes$name,      # Set of genes of interest (from HPO in this case)\n  OrgDb         = org.Hs.eg.db,        # Gene annotation database\n  keyType       = \"SYMBOL\",            # Type of gene identification (here, gene symbols)\n  ont           = \"BP\",                # Ontology (BP: biological processes)\n  pAdjustMethod = \"BH\",                # Method for p-value adjustment\n  pvalueCutoff  = 0.05,                # Significance threshold for p-value\n  qvalueCutoff  = 0.2                  # Significance threshold for q-value\n)\n\n# Mostrar resultados\nhead(enrich_results)\n\n\n\n3.3.4 Explicación de Argumentos Clave en enrichGO\n\ngene: La lista de genes de interés. En este caso, es una lista de genes asociados con el fenotipo del HPO.\nOrgDb: Base de datos que contiene la información de anotación de genes (en este caso, org.Hs.eg.db para genes humanos).\nkeyType: Tipo de identificación de los genes (por ejemplo, “SYMBOL” para nombres de genes, “ENTREZID” para IDs de Entrez).\nont: Especifica la ontología GO (BP: Biological Process, MF: Molecular Function, CC: Cellular Component).\npAdjustMethod: Método para ajustar los valores de p, siendo “BH” (Benjamini-Hochberg) una elección común.\npvalueCutoff y qvalueCutoff: Define los umbrales de significancia para p-valores y q-valores.\n\n\n\n\n\n\n\nCautionP and Q values\n\n\n\n\n\nEl valor p y el valor q son métricas utilizadas en pruebas estadísticas para evaluar la significancia de los resultados, aunque tienen propósitos ligeramente diferentes:\n\nValor p: Representa la probabilidad de que los resultados observados (o más extremos) ocurran por azar si no hubiera un efecto real. En el contexto de análisis de enriquecimiento, un valor p bajo indica que un término o vía específica probablemente esté enriquecido en el conjunto de genes debido a una asociación verdadera y no al azar. Sin embargo, cuando se prueban múltiples hipótesis (como en un análisis de enriquecimiento con muchos términos), el uso de valores p sin ajuste puede llevar a una alta tasa de falsos positivos.\nValor q: Es una forma ajustada del valor p que se enfoca en controlar la tasa de descubrimientos falsos (FDR), o sea, la proporción esperada de falsos positivos entre todos los resultados positivos. El valor q considera las múltiples comparaciones y es especialmente útil en análisis de enriquecimiento, donde se prueban muchos términos. Un umbral de valor q (como q &lt; 0.2) ayuda a limitar el porcentaje de descubrimientos falsos, y es una forma más conservadora de interpretar resultados con muchas pruebas.\n\nEn resumen:\n\nValor p es la medida de significancia estadística sin ajuste.\nValor q es el valor p ajustado para controlar la tasa de descubrimientos falsos, proporcionando una estimación más confiable de la significancia en pruebas de gran escala.\n\n\n3.3.4.1 Pregunta de reflexión:\n¿Por qué es importante considerar tanto el valor p como el valor q al interpretar los resultados de un análisis de enriquecimiento?\nEl valor p nos da una medida de la significancia estadística de los resultados, indicando qué tan probable es que un término esté enriquecido debido a una asociación verdadera y no al azar. Sin embargo, en análisis de enriquecimiento, donde se evalúan múltiples términos de manera simultánea, el valor p sin ajustar podría conducir a una alta tasa de falsos positivos. Por ello, el valor q es crucial, ya que ajusta el valor p para controlar la tasa de descubrimientos falsos (FDR), proporcionando una interpretación más confiable y conservadora de los resultados. Usar ambos valores ayuda a evitar conclusiones erróneas y a identificar términos que tienen una relevancia más sólida en el contexto del análisis.\n\n\n\n\n\n\n3.3.5 Visualización de los Resultados de Enriquecimiento\nclusterProfiler permite visualizar términos GO enriquecidos con dotplot y barplot.\n\nif (!requireNamespace(\"enrichplot\", quietly = TRUE)) BiocManager::install(\"enrichplot\")\nlibrary(enrichplot)\n\n# Dotplot to visualize enriched GO terms\ndotplot(enrich_results, showCategory = 10, title = \"GO Enrichment for Abnormal Renal Corpuscle Morphology\")\n\n# Barplot as an alternative\nbarplot(enrich_results, showCategory = 10, title = \"GO Enrichment Barplot\")\n\n\n3.3.5.1 También podemos exportar los resultados a CSV o visualizarlos en tablas.\n\n# Convert results to data frame and export to CSV\nwrite.csv2(as.data.frame(enrich_results), file = \"GO_Enrichment_Abnormal_Renal_Corpuscle.csv\", row.names = FALSE)\n\n# View as a table in R\nhead(as.data.frame(enrich_results))\n\n\n\n\n3.3.6 Análisis de Enriquecimiento en Clusters de una Red\nCuando trabajamos con redes de genes, el análisis de enriquecimiento funcional puede aplicarse a clusters individuales para identificar funciones únicas en cada grupo de genes.\nPara realizar un Análisis de Enriquecimiento en Clusters de una Red en R, partiremos tambien de la red STRINGdb del termino HPO “abnormal renal corpuscle morphology” que ya ha sido agrupada en diferentes clusters (por ejemplo, usando el algoritmo de Louvain en una sección previa). Esto permite aplicar análisis de enriquecimiento a cada uno de los clusters obtenidos para identificar funciones biológicas o rutas moleculares específicas asociadas con cada grupo de genes.\n\n3.3.6.1 Extracción de Genes de Clusters para Análisis de Enriquecimiento\n\nAsignación de Clusters a los Nodos: Partimos de un grafo en el que cada nodo ya tiene asignado un número de cluster.\nExtracción de Genes por Cluster: Utilizamos una función para extraer los genes de cada cluster.\n\nEl siguiente código ilustra cómo extraer los genes de cada cluster en el grafo previamente agrupado del termino HPO.\n\n# Create the graph\ng &lt;- graph_from_data_frame(interaction_network, directed = FALSE)\ncluster_louvain &lt;- cluster_louvain(g)\nset.seed(123)\n\ncluster_membership &lt;- membership(cluster_louvain(g)) # Louvain clustering on the graph\n# Split genes by cluster\ngenes_clusters &lt;- split(V(g)$name, cluster_membership)  # Names of genes by cluster\n\n# Look at the genes in each cluster. What pathways/GO terms do you think might be enriched?\nprint(genes_clusters)\n\n\n\n3.3.6.2 Aplicación del Análisis de Enriquecimiento ORA en Cada Cluster\nCon los genes divididos por clusters, aplicaremos el análisis de enriquecimiento Over-Representation Analysis (ORA) en cada uno. Esto permite identificar procesos biológicos o funciones moleculares específicas para los genes de cada grupo. Usaremos el paquete clusterProfiler y nos enfocaremos en el análisis de enriquecimiento GO.\n\n# Initialize an empty list to store enrichment results for each cluster\nenrichment_results_clusters &lt;- list()\n\n# Loop over each cluster to perform enrichment analysis\nfor (i in seq_along(genes_clusters)) {\n  cat(i, \"\\n\")\n  # Perform GO enrichment for the current cluster\n  enrichment_results_clusters[[i]] &lt;- enrichGO(\n    gene          = genes_clusters[[i]],   # Set of genes for the current cluster\n    OrgDb         = org.Hs.eg.db,          # Database for gene annotation\n    keyType       = \"SYMBOL\",              # Identifier type (e.g., gene symbols)\n    ont           = \"BP\",                  # Ontology (BP: Biological Process)\n    pAdjustMethod = \"BH\",                  # Method for p-value adjustment\n    pvalueCutoff  = 0.05,                  # Significance threshold for p-value\n    qvalueCutoff  = 0.2                    # Significance threshold for q-value\n  )\n}\n\n# Visualize results for the first cluster as an example\ndotplot(enrichment_results_clusters[[1]], showCategory = 10, title = \"GO Enrichment for Cluster 1\")\n\n# Save enrichment results to CSV files for each cluster\nfor (i in seq_along(enrichment_results_clusters)) {\n  write.csv2(\n    as.data.frame(enrichment_results_clusters[[i]]),  # Convert to data frame for saving\n    file = paste0(\"enrichment_cluster_\", i, \".csv\")   # File name based on cluster index\n  )\n}\n\nAhora utiliza un dotplot para visualizar los resultados de los primeros, terceros y cuartos clusters. ¿Cómo se comparan los resultados con la intuición formada al mirar las listas de genes?\n\n\n3.3.6.3 Preguntas\n¿Por qué es importante el análisis de enriquecimiento funcional? El análisis de enriquecimiento funcional es fundamental en bioinformática porque permite a los investigadores identificar patrones significativos dentro de grandes conjuntos de datos genómicos y transcriptómicos. Al revelar qué procesos biológicos, rutas o funciones moleculares están sobrerrepresentados en un conjunto de genes, facilita la interpretación de los resultados experimentales. Esto es esencial para formular hipótesis sobre la biología subyacente de enfermedades o tratamientos y para priorizar futuras investigaciones.\n¿Cómo deberíamos interpretar los resultados del análisis de enriquecimiento?\nLa interpretación de los términos enriquecidos depende del contexto biológico de los genes de interés. Por ejemplo, si los genes seleccionados están asociados con una enfermedad renal, los términos enriquecidos relacionados con funciones como la apoptosis o la inflamación pueden indicar procesos relevantes en la patología. Comprender el contexto ayuda a filtrar los resultados y a dirigir la investigación hacia áreas biológicamente significativas.\n¿Por qué son importantes las visualizaciones de datos para el análisis de enriquecimiento?\nLas visualizaciones, como los dotplots y emapplots, son esenciales para comprender y comunicar los resultados del análisis de enriquecimiento. Estas herramientas permiten a los investigadores identificar rápidamente patrones, relaciones y la relevancia de diferentes términos enriquecidos en el contexto de su conjunto de genes. La visualización facilita destacar hallazgos clave y presentar los resultados de manera más accesible, fomentando colaboraciones y discusiones entre investigadores.\n¿Qué conocimientos se pueden obtener al realizar un análisis de enriquecimiento en clusters de una red?\nRealizar un análisis de enriquecimiento en clusters de una red puede revelar diferencias significativas en los términos enriquecidos a lo largo de grupos de genes. Por ejemplo, un cluster que agrupa genes involucrados en la respuesta inmune puede mostrar un enriquecimiento en términos relacionados con la inflamación, mientras que otro cluster puede estar enriquecido en términos relacionados con la regulación del ciclo celular. Estas diferencias ofrecen una visión de cómo diferentes grupos de genes contribuyen a procesos biológicos específicos, ayudando a delimitar funciones y relaciones dentro de la red.\n¿Cómo informan los resultados de enriquecimiento sobre la relación entre genes y fenotipo?\nLos resultados del análisis de enriquecimiento pueden proporcionar información sobre la relación entre los genes analizados y el fenotipo de interés, como la morfología anormal del corpúsculo renal. Si los términos enriquecidos sugieren una disfunción en procesos como la filtración o la regulación del crecimiento celular, esto puede implicar mecanismos biológicos subyacentes al fenotipo observado. Este conocimiento es valioso para comprender mejor la biología de la enfermedad y potencialmente guiar investigaciones futuras hacia objetivos terapéuticos.\n¿Cuáles son algunas aplicaciones prácticas del análisis de enriquecimiento?\nEl análisis de enriquecimiento tiene muchas aplicaciones prácticas, como el desarrollo de tratamientos y la comprensión de enfermedades. Por ejemplo, identificar rutas biológicas alteradas en un tipo específico de cáncer puede ayudar a los investigadores a diseñar terapias dirigidas a estas rutas. También es útil en estudios de farmacogenómica, donde el objetivo es comprender cómo las variaciones genéticas influyen en la respuesta a los medicamentos. Estos análisis proporcionan conocimientos que pueden guiar la investigación traslacional y la práctica clínica, mejorando la precisión y efectividad de las intervenciones médicas.\n\n\n\n3.3.7 Otros métodos de visualización en clusterProfiler:\ndotplot: El dotplot muestra el enriquecimiento de términos en diferentes clusters de genes. Cada punto representa un término, donde el tamaño indica el nivel de significancia o la cantidad de genes asociados. Es útil para identificar patrones de enriquecimiento y comparar la relevancia de varios términos entre clusters.\nemapplot: El emapplot visualiza las relaciones entre los términos de enriquecimiento, mostrando cómo se conectan entre sí. Los nodos representan términos y las conexiones indican similitudes o superposiciones. Este gráfico es útil para entender la estructura de los términos en un contexto más amplio.\nAhora consulta la página de ayuda para estas funciones y úsalas para graficar algunos de tus clusters.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Práctica Redes 2: Clusterizacion y Enriquecimiento Funcional</span>"
    ]
  },
  {
    "objectID": "summary.html",
    "href": "summary.html",
    "title": "4  Summary",
    "section": "",
    "text": "In summary, this book has no content whatsoever.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Summary</span>"
    ]
  }
]