<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.45">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>3&nbsp; Práctica Redes 2: Clusterizacion y Enriquecimiento Funcional – BMS</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="./summary.html" rel="next">
<link href="./hpo_redes1.html" rel="prev">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


</head>

<body class="nav-sidebar floating">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./hpo_redes2.html"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Práctica Redes 2: Clusterizacion y Enriquecimiento Funcional</span></a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="Search" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="./">BMS</a> 
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Preface</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./reintro_a_r.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">(Re)introducción a R para Biología y Bioinformática</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./hpo_redes1.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Practica Redes 1: Análisis de redes con R y iGRAPH:</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./hpo_redes2.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Práctica Redes 2: Clusterizacion y Enriquecimiento Funcional</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./summary.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Summary</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./references.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">References</span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#parte-1-regenerando-la-red-de-interacción-recordatorio" id="toc-parte-1-regenerando-la-red-de-interacción-recordatorio" class="nav-link active" data-scroll-target="#parte-1-regenerando-la-red-de-interacción-recordatorio"><span class="header-section-number">3.1</span> Parte 1: Regenerando la Red de Interacción (Recordatorio)</a>
  <ul class="collapse">
  <li><a href="#qué-es-stringdb" id="toc-qué-es-stringdb" class="nav-link" data-scroll-target="#qué-es-stringdb"><span class="header-section-number">3.1.1</span> ¿Qué es STRINGdb?</a></li>
  <li><a href="#preguntas-de-reflexión-recordatorios" id="toc-preguntas-de-reflexión-recordatorios" class="nav-link" data-scroll-target="#preguntas-de-reflexión-recordatorios"><span class="header-section-number">3.1.2</span> Preguntas de Reflexión (recordatorios)</a></li>
  </ul></li>
  <li><a href="#parte-2-clustering-de-la-red-con-igraph" id="toc-parte-2-clustering-de-la-red-con-igraph" class="nav-link" data-scroll-target="#parte-2-clustering-de-la-red-con-igraph"><span class="header-section-number">3.2</span> Parte 2: Clustering de la Red con igraph</a>
  <ul class="collapse">
  <li><a href="#qué-es-el-clustering" id="toc-qué-es-el-clustering" class="nav-link" data-scroll-target="#qué-es-el-clustering"><span class="header-section-number">3.2.1</span> ¿Qué es el clustering?</a></li>
  <li><a href="#teoría-detrás-del-clustering" id="toc-teoría-detrás-del-clustering" class="nav-link" data-scroll-target="#teoría-detrás-del-clustering"><span class="header-section-number">3.2.2</span> Teoría Detrás del Clustering</a></li>
  <li><a href="#distintos-algoritmos-para-clusterizar-una-red" id="toc-distintos-algoritmos-para-clusterizar-una-red" class="nav-link" data-scroll-target="#distintos-algoritmos-para-clusterizar-una-red"><span class="header-section-number">3.2.3</span> Distintos algoritmos para clusterizar una red</a></li>
  </ul></li>
  <li><a href="#functional-enrichment" id="toc-functional-enrichment" class="nav-link" data-scroll-target="#functional-enrichment"><span class="header-section-number">3.3</span> Functional Enrichment</a>
  <ul class="collapse">
  <li><a href="#introducción-al-análisis-de-enriquecimiento-funcional" id="toc-introducción-al-análisis-de-enriquecimiento-funcional" class="nav-link" data-scroll-target="#introducción-al-análisis-de-enriquecimiento-funcional"><span class="header-section-number">3.3.1</span> Introducción al Análisis de Enriquecimiento Funcional</a></li>
  <li><a href="#enfoque-práctico-análisis-de-sobrerrepresentación-ora" id="toc-enfoque-práctico-análisis-de-sobrerrepresentación-ora" class="nav-link" data-scroll-target="#enfoque-práctico-análisis-de-sobrerrepresentación-ora"><span class="header-section-number">3.3.2</span> Enfoque Práctico: Análisis de Sobrerrepresentación (ORA)</a></li>
  <li><a href="#ora-aplicado-a-genes-asociados-con-el-término-hpo-morfología-anormal-del-corpúsculo-renal" id="toc-ora-aplicado-a-genes-asociados-con-el-término-hpo-morfología-anormal-del-corpúsculo-renal" class="nav-link" data-scroll-target="#ora-aplicado-a-genes-asociados-con-el-término-hpo-morfología-anormal-del-corpúsculo-renal"><span class="header-section-number">3.3.3</span> ORA aplicado a Genes Asociados con el Término HPO “Morfología Anormal del Corpúsculo Renal”</a></li>
  <li><a href="#explicación-de-argumentos-clave-en-enrichgo" id="toc-explicación-de-argumentos-clave-en-enrichgo" class="nav-link" data-scroll-target="#explicación-de-argumentos-clave-en-enrichgo"><span class="header-section-number">3.3.4</span> Explicación de Argumentos Clave en enrichGO</a></li>
  <li><a href="#visualización-de-los-resultados-de-enriquecimiento" id="toc-visualización-de-los-resultados-de-enriquecimiento" class="nav-link" data-scroll-target="#visualización-de-los-resultados-de-enriquecimiento"><span class="header-section-number">3.3.5</span> Visualización de los Resultados de Enriquecimiento</a></li>
  <li><a href="#análisis-de-enriquecimiento-en-clusters-de-una-red" id="toc-análisis-de-enriquecimiento-en-clusters-de-una-red" class="nav-link" data-scroll-target="#análisis-de-enriquecimiento-en-clusters-de-una-red"><span class="header-section-number">3.3.6</span> Análisis de Enriquecimiento en Clusters de una Red</a></li>
  <li><a href="#otros-métodos-de-visualización-en-clusterprofiler" id="toc-otros-métodos-de-visualización-en-clusterprofiler" class="nav-link" data-scroll-target="#otros-métodos-de-visualización-en-clusterprofiler"><span class="header-section-number">3.3.7</span> Otros métodos de visualización en clusterProfiler:</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Práctica Redes 2: Clusterizacion y Enriquecimiento Funcional</span></h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<p>En este práctico, nos enfocaremos en regenerar la red de interacción genética de la semana pasada utilizando STRINGdb. Luego, aplicaremos algoritmos de clustering para identificar grupos de genes altamente conectados. Posteriormente, realizaremos un análisis de sobre-representación utilizando clusterProfiler para interpretar los posibles roles biológicos de estas comunidades. Finalmente, visualizaremos los resultados de enriquecimiento de manera clara y efectiva. Usaremos los genes asociados al fenotipo de morfología anormal del corpúsculo renal que obtuvimos en la práctica anterior.</p>
<section id="parte-1-regenerando-la-red-de-interacción-recordatorio" class="level2" data-number="3.1">
<h2 data-number="3.1" class="anchored" data-anchor-id="parte-1-regenerando-la-red-de-interacción-recordatorio"><span class="header-section-number">3.1</span> Parte 1: Regenerando la Red de Interacción (Recordatorio)</h2>
<p>En esta sección, recordaremos cómo construir una red de interacción utilizando STRINGdb y convertirla a un formato que podamos usar con la librería igraph en R.</p>
<section id="qué-es-stringdb" class="level3" data-number="3.1.1">
<h3 data-number="3.1.1" class="anchored" data-anchor-id="qué-es-stringdb"><span class="header-section-number">3.1.1</span> ¿Qué es STRINGdb?</h3>
<p>STRINGdb es una base de datos que proporciona información sobre interacciones entre proteínas y genes, así como las evidencias que respaldan estas interacciones. Utiliza datos de diversas fuentes, incluyendo experimentos de laboratorio, datos de literatura y predicciones computacionales.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Load required packages</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> (<span class="sc">!</span><span class="fu">requireNamespace</span>(<span class="st">"igraph"</span>, <span class="at">quietly =</span> <span class="cn">TRUE</span>)) <span class="fu">install.packages</span>(<span class="st">"httr"</span>)</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> (<span class="sc">!</span><span class="fu">requireNamespace</span>(<span class="st">"igraph"</span>, <span class="at">quietly =</span> <span class="cn">TRUE</span>)) <span class="fu">install.packages</span>(<span class="st">"jsonlite"</span>)</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> (<span class="sc">!</span><span class="fu">requireNamespace</span>(<span class="st">"igraph"</span>, <span class="at">quietly =</span> <span class="cn">TRUE</span>)) <span class="fu">install.packages</span>(<span class="st">"igraph"</span>)</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> (<span class="sc">!</span><span class="fu">requireNamespace</span>(<span class="st">"STRINGdb"</span>, <span class="at">quietly =</span> <span class="cn">TRUE</span>)) BiocManager<span class="sc">::</span><span class="fu">install</span>(<span class="st">"STRINGdb"</span>)</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(httr)</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(jsonlite)</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(igraph)</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(STRINGdb)</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a><span class="co"># API request to get genes associated with the HPO term for abnormal renal corpuscle morphology</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>hpo_id <span class="ot">&lt;-</span> <span class="st">"HP:0031263"</span>  <span class="co"># HPO ID for abnormal renal corpuscle morphology</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>url <span class="ot">&lt;-</span> <span class="fu">paste0</span>(<span class="st">"https://ontology.jax.org/api/network/annotation/"</span>, hpo_id)</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>response <span class="ot">&lt;-</span> <span class="fu">GET</span>(url)</span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>data <span class="ot">&lt;-</span> <span class="fu">content</span>(response, <span class="at">as =</span> <span class="st">"text"</span>, <span class="at">encoding =</span> <span class="st">"UTF-8"</span>)</span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>genes <span class="ot">&lt;-</span> <span class="fu">fromJSON</span>(data)<span class="sc">$</span>genes</span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a><span class="co"># Initialize STRINGdb</span></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a><span class="co"># Can you see anything different here compared to the last practical?</span></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>string_db <span class="ot">&lt;-</span> STRINGdb<span class="sc">$</span><span class="fu">new</span>(<span class="at">version =</span> <span class="st">"12"</span>, <span class="at">species =</span> <span class="dv">9606</span>, <span class="at">score_threshold =</span> <span class="dv">400</span>, <span class="at">input_directory =</span> <span class="st">""</span>)</span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a>string_ids <span class="ot">&lt;-</span> string_db<span class="sc">$</span><span class="fu">map</span>( genes, <span class="st">"name"</span>, <span class="at">removeUnmappedRows =</span> <span class="cn">TRUE</span> )</span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a>interaction_network <span class="ot">&lt;-</span> string_db<span class="sc">$</span><span class="fu">get_interactions</span>(string_ids<span class="sc">$</span>STRING_id)</span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a>interaction_network <span class="ot">&lt;-</span> <span class="fu">unique</span>(interaction_network[, <span class="dv">1</span><span class="sc">:</span><span class="dv">2</span>]) <span class="co"># necessary step to remove duplicate interactions</span></span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a>interaction_network<span class="sc">$</span>to <span class="ot">&lt;-</span> string_ids<span class="sc">$</span>name[<span class="fu">match</span>(interaction_network<span class="sc">$</span>to, string_ids<span class="sc">$</span>STRING_id)]</span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a>interaction_network<span class="sc">$</span>from <span class="ot">&lt;-</span> string_ids<span class="sc">$</span>name[<span class="fu">match</span>(interaction_network<span class="sc">$</span>from, string_ids<span class="sc">$</span>STRING_id)]</span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a><span class="co"># How can I see how big the network is? How does it compare to last week?</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="preguntas-de-reflexión-recordatorios" class="level3" data-number="3.1.2">
<h3 data-number="3.1.2" class="anchored" data-anchor-id="preguntas-de-reflexión-recordatorios"><span class="header-section-number">3.1.2</span> Preguntas de Reflexión (recordatorios)</h3>
<p><em>¿Qué tipo de información proporciona STRINGdb sobre las interacciones entre genes?</em></p>
<pre><code>STRINGdb proporciona una amplia gama de información sobre las interacciones entre genes y proteínas. Esto incluye interacciones físicas directas, como enlaces proteicos, e interacciones funcionales, donde las proteínas pueden estar involucradas en los mismos procesos biológicos sin interactuar físicamente. Las interacciones están respaldadas por diferentes tipos de evidencias, como datos experimentales, coexpresión, similitud de dominios, y estudios computacionales. Además, STRINGdb asigna una puntuación de confianza (confidence score) a cada interacción, lo que ayuda a evaluar la fiabilidad de la conexión entre los genes o proteínas en la red.</code></pre>
<p><em>¿Por qué es importante establecer un umbral de puntuación (score_threshold) al obtener interacciones?</em></p>
<pre><code>El umbral de puntuación (score_threshold) es crucial porque permite filtrar las interacciones según su grado de confianza o fiabilidad. STRINGdb asigna un score a cada interacción basado en la calidad y cantidad de evidencia que respalda la relación entre los genes o proteínas. Un valor más alto indica una mayor confianza en la interacción. Al ajustar el umbral, se puede obtener una red más robusta y precisa, eliminando interacciones que podrían ser falsas o de baja confianza. Si el umbral es muy bajo, podrías obtener demasiadas interacciones espureas; si es demasiado alto, podrías perder conexiones importantes pero menos documentadas.</code></pre>
<p><em>¿Cómo se relacionan las interacciones en la red con las funciones biológicas de los genes involucrados?</em></p>
<pre><code>Las interacciones en la red pueden proporcionar información clave sobre las funciones biológicas de los genes involucrados. Genes que estén conectados en una red suelen participar en procesos biológicos relacionados, como rutas metabólicas, señalización celular, o respuestas a estímulos. Las redes permiten identificar módulos o agrupaciones de genes que trabajan juntos, lo cual puede revelar nuevas funciones biológicas o ayudar a comprender mejor las rutas moleculares en las que participan. Al analizar estas interacciones, los investigadores pueden inferir funciones desconocidas para algunos genes basándose en los genes con los que están conectados en la red, un concepto conocido como "guilt by association".</code></pre>
</section>
</section>
<section id="parte-2-clustering-de-la-red-con-igraph" class="level2" data-number="3.2">
<h2 data-number="3.2" class="anchored" data-anchor-id="parte-2-clustering-de-la-red-con-igraph"><span class="header-section-number">3.2</span> Parte 2: Clustering de la Red con igraph</h2>
<section id="qué-es-el-clustering" class="level3" data-number="3.2.1">
<h3 data-number="3.2.1" class="anchored" data-anchor-id="qué-es-el-clustering"><span class="header-section-number">3.2.1</span> ¿Qué es el clustering?</h3>
<p>El clustering en redes es el proceso de identificar grupos de nodos (genes, en este caso) que están más densamente conectados entre sí que con otros nodos de la red. Este enfoque permite detectar módulos o clusters, que pueden representar vías de señalización o grupos funcionales de genes que operan juntos.</p>
</section>
<section id="teoría-detrás-del-clustering" class="level3" data-number="3.2.2">
<h3 data-number="3.2.2" class="anchored" data-anchor-id="teoría-detrás-del-clustering"><span class="header-section-number">3.2.2</span> Teoría Detrás del Clustering</h3>
<section id="conceptos-fundamentales" class="level4" data-number="3.2.2.1">
<h4 data-number="3.2.2.1" class="anchored" data-anchor-id="conceptos-fundamentales"><span class="header-section-number">3.2.2.1</span> Conceptos Fundamentales</h4>
<ol type="1">
<li><p>Teoría de Grafos: En el contexto de las redes, los grafos se componen de nodos (genes) y aristas (interacciones).</p></li>
<li><p>Centralidad (Centrality): La centralidad mide la importancia de un nodo dentro de la red. Hay varias formas de calcular la centralidad:</p>
<ul>
<li>Centralidad de Grado (Degree Centrality): Número de conexiones que tiene un nodo. Un alto grado puede indicar un nodo clave en la red.</li>
<li>Centralidad de Intermediación (Betweenness Centrality): Indica cuántas veces un nodo actúa como un puente a lo largo de los caminos más cortos entre otros nodos. Los nodos con alta centralidad de intermediación pueden controlar la comunicación en la red.</li>
<li>Centralidad de Cercanía (Closeness Centrality): Mide qué tan cerca está un nodo de todos los demás nodos en la red, lo que puede reflejar su capacidad para acceder rápidamente a información.</li>
</ul></li>
<li><p>Densidad (Network Density): Se refiere a la proporción de conexiones existentes en la red en comparación con el número máximo posible de conexiones. Una red densa puede indicar una alta interconexión entre nodos, lo cual es fundamental para la identificación de clusters.</p></li>
<li><p>Modularidad (Modularity): La modularidad es una medida de la estructura de la red que indica la calidad de la división en módulos o clusters. Un clustering con alta modularidad tiene muchas conexiones dentro de los clusters y pocas entre ellos. La optimización de la modularidad es un objetivo común en muchos algoritmos de clustering.</p></li>
<li><p>Caminos y Conectividad (Paths and Connectivity): La existencia de caminos cortos y la conectividad entre nodos son cruciales para el clustering. Los clusters suelen tener caminos más cortos entre sus nodos que con nodos externos, lo que refleja su cohesión.</p></li>
</ol>
</section>
<section id="visualizando-los-conceptos" class="level4" data-number="3.2.2.2">
<h4 data-number="3.2.2.2" class="anchored" data-anchor-id="visualizando-los-conceptos"><span class="header-section-number">3.2.2.2</span> Visualizando los conceptos</h4>
<p>Para ilustrar estos conceptos, utilizaremos la función `<code>sample_islands</code> de igraph para crear un grafo sintético compuesto por “islas” o clústeres densamente conectados y parcialmente aislados. Este tipo de red es ideal para demostrar varios principios importantes de la teoría de grafos y el análisis de redes, incluyendo centralidad, modularidad, densidad y conectividad. A continuación, se explica cómo se relaciona con cada uno de estos principios:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Load required packages</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> (<span class="sc">!</span><span class="fu">requireNamespace</span>(<span class="st">"igraph"</span>, <span class="at">quietly =</span> <span class="cn">TRUE</span>)) <span class="fu">install.packages</span>(<span class="st">"igraph"</span>)</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(igraph)</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Create a network to illustrate important principles</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>g <span class="ot">&lt;-</span> <span class="fu">sample_islands</span>(<span class="dv">3</span>, <span class="dv">30</span>, <span class="fl">0.9</span>, <span class="dv">10</span>)</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Visualize the graph</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(g, <span class="at">vertex.size=</span><span class="dv">5</span>, <span class="at">vertex.label=</span><span class="cn">NA</span>, <span class="at">edge.arrow.size=</span><span class="fl">0.2</span>, <span class="at">main=</span><span class="st">"Red de islas para mostrar propiedades relacionadas con el clustering"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="cómo-la-red-de-sample_islands-demuestra-estos-principios" class="level4" data-number="3.2.2.3">
<h4 data-number="3.2.2.3" class="anchored" data-anchor-id="cómo-la-red-de-sample_islands-demuestra-estos-principios"><span class="header-section-number">3.2.2.3</span> Cómo la Red de Sample_Islands Demuestra Estos Principios:</h4>
<ul>
<li><p>Intra-isla: Los nodos dentro de las islas están densamente conectados, mostrando una alta densidad local, caminos cortos y alta modularidad dentro de los clústeres. Estos nodos tienen una centralidad de grado y cercanía alta en relación con su propia isla.</p></li>
<li><p>Inter-isla: Los nodos que conectan diferentes islas poseen una alta centralidad de intermediación, ya que funcionan como puentes entre diferentes comunidades. Estos nodos controlan el flujo de información a través de la red.</p></li>
<li><p>La escasez de conexiones entre islas demuestra cómo una baja densidad global y caminos más largos entre clústeres crean clústeres bien separados, ideales para agrupamiento basado en modularidad.</p></li>
</ul>
</section>
</section>
<section id="distintos-algoritmos-para-clusterizar-una-red" class="level3" data-number="3.2.3">
<h3 data-number="3.2.3" class="anchored" data-anchor-id="distintos-algoritmos-para-clusterizar-una-red"><span class="header-section-number">3.2.3</span> Distintos algoritmos para clusterizar una red</h3>
<section id="generación-de-una-red-con-estructura-core-periphery" class="level4" data-number="3.2.3.1">
<h4 data-number="3.2.3.1" class="anchored" data-anchor-id="generación-de-una-red-con-estructura-core-periphery"><span class="header-section-number">3.2.3.1</span> Generación de una Red con Estructura Core-Periphery</h4>
<p>Vamos a generar una red que simule una estructura core-periphery usando la librería igraph. Esta estructura nos permitirá ver cómo los diferentes algoritmos de clustering lidian con un núcleo denso de nodos interconectados y una periferia menos conectada.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Generate a core-periphery network</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">123</span>)</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>g <span class="ot">&lt;-</span> <span class="fu">sample_gnp</span>(<span class="dv">50</span>, <span class="fl">0.05</span>)  <span class="co"># Periphery: sparse network</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>core_nodes <span class="ot">&lt;-</span> <span class="fu">sample</span>(<span class="dv">1</span><span class="sc">:</span><span class="fu">vcount</span>(g), <span class="dv">10</span>)  <span class="co"># Select core nodes</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>g <span class="ot">&lt;-</span> <span class="fu">add_edges</span>(g, <span class="fu">combn</span>(core_nodes, <span class="dv">2</span>))  <span class="co"># Add dense connections in the core</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a><span class="fu">V</span>(g)<span class="sc">$</span>color <span class="ot">&lt;-</span> <span class="fu">ifelse</span>(<span class="dv">1</span><span class="sc">:</span><span class="fu">vcount</span>(g) <span class="sc">%in%</span> core_nodes, <span class="st">"red"</span>, <span class="st">"blue"</span>)  <span class="co"># Color nodes based on core or periphery</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a><span class="co"># Visualize the network</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">123</span>)</span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(g, <span class="at">vertex.size=</span><span class="dv">5</span>, <span class="at">vertex.label=</span><span class="cn">NA</span>, <span class="at">edge.arrow.size=</span><span class="fl">0.2</span>, <span class="at">main=</span><span class="st">"Core-periphery network"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>En esta red, los nodos rojos representan el núcleo, un grupo densamente interconectado, mientras que los nodos azules representan la periferia, que tiene conexiones más dispersas. Esta estructura simula la organización biológica donde un grupo central de genes podría estar estrechamente vinculado funcionalmente, mientras que los genes periféricos podrían estar involucrados en funciones más especializadas o de soporte.</p>
</section>
<section id="generación-de-una-red-tipo-barabásialbert" class="level4" data-number="3.2.3.2">
<h4 data-number="3.2.3.2" class="anchored" data-anchor-id="generación-de-una-red-tipo-barabásialbert"><span class="header-section-number">3.2.3.2</span> Generación de una Red tipo Barabási–Albert</h4>
<p>Vamos a generar una red que simule una red de tipo libre de escala. Esto es un modelo de red basado en “rich get richer” o de ventaja acumulativa. Los nodos con mayor grado tienen mayor probabilidad de generar nuevas conexiones que los de menor grado. La distribución del grado de los nodos sigue una ley de potencial.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Generate a core-periphery network</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">123</span>)</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>g_ba <span class="ot">&lt;-</span> <span class="fu">sample_pa</span>(<span class="dv">100</span>, <span class="at">power =</span> <span class="fl">1.9</span>, <span class="at">directed =</span> <span class="cn">FALSE</span>)</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(g_ba, <span class="at">vertex.size=</span><span class="dv">5</span>, <span class="at">vertex.label=</span><span class="cn">NA</span>, <span class="at">edge.arrow.size=</span><span class="fl">0.2</span>, <span class="at">main=</span><span class="st">"Core-periphery network"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="algoritmos-de-clustering" class="level4" data-number="3.2.3.3">
<h4 data-number="3.2.3.3" class="anchored" data-anchor-id="algoritmos-de-clustering"><span class="header-section-number">3.2.3.3</span> Algoritmos de Clustering</h4>
<ol type="1">
<li>Algoritmo de Louvain</li>
</ol>
<p>El algoritmo de Louvain optimiza la modularidad, agrupando nodos de manera que se maximicen las conexiones dentro de los clusters y se minimicen entre clusters. Este algoritmo es eficiente para redes grandes y suele identificar grandes clusters en el núcleo.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Clustering using the Louvain algorithm</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>cluster_louvain <span class="ot">&lt;-</span> <span class="fu">cluster_louvain</span>(g)</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">123</span>)</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(cluster_louvain, g, <span class="at">vertex.size=</span><span class="dv">5</span>, <span class="at">vertex.label=</span><span class="cn">NA</span>, <span class="at">edge.arrow.size=</span><span class="fl">0.2</span>, <span class="at">main=</span><span class="st">"Clustering with Louvain"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<ul>
<li><p>Observación: En redes core-periphery, Louvain puede identificar el núcleo como un único cluster grande, mientras que los nodos periféricos pueden agruparse en pequeños clusters dispersos.</p></li>
<li><p>Enfoque tipo agregativo no jerárquico.</p></li>
</ul>
<ol start="2" type="1">
<li>Algoritmo de Girvan-Newman</li>
</ol>
<p>El algoritmo de Girvan-Newman se basa en la eliminación de aristas con alta centralidad de intermediación. Al eliminar las conexiones clave (de alta centralidad de intermediación), divide la red en clusters más pequeños, lo que puede descomponer el núcleo en subclusters.Posee alto coste computacional, así que es mejor sólo para redes medianas o pequeñas.</p>
<ul>
<li>Enfoque jerárquico y divisivo.</li>
</ul>
<div class="cell">
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Clustering using the Girvan-Newman algorithm</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>cluster_girvan_newman <span class="ot">&lt;-</span> <span class="fu">cluster_edge_betweenness</span>(g)</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">123</span>)</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(cluster_girvan_newman, g, <span class="at">vertex.size=</span><span class="dv">5</span>, <span class="at">vertex.label=</span><span class="cn">NA</span>, <span class="at">edge.arrow.size=</span><span class="fl">0.2</span>, <span class="at">main=</span><span class="st">"Clustering with Girvan-Newman"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<ul>
<li>Observación: Girvan-Newman es capaz de dividir las comunidades de manera solapante.</li>
</ul>
<ol start="3" type="1">
<li>Algoritmo de Infomap El algoritmo Infomap utiliza flujos de información para identificar clusters en la red. Al modelar cómo se transmite la información entre los nodos, Infomap puede identificar tanto clusters en el núcleo como en la periferia. De gran escalabilidad para redes grandes.</li>
</ol>
<div class="cell">
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Clustering using the Infomap algorithm</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>cluster_infomap <span class="ot">&lt;-</span> <span class="fu">cluster_infomap</span>(g)</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">123</span>)</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(cluster_infomap, g, <span class="at">vertex.size=</span><span class="dv">5</span>, <span class="at">vertex.label=</span><span class="cn">NA</span>, <span class="at">edge.arrow.size=</span><span class="fl">0.2</span>, <span class="at">main=</span><span class="st">"Clustering with Infomap"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<ul>
<li>Observación: Infomap es particularmente útil para identificar subestructuras ocultas dentro de redes complejas como las de core-periphery, donde el flujo de información entre nodos puede revelar clusters que otros algoritmos pasan por alto.</li>
</ul>
<p>Reflexión sobre los Resultados Cada uno de estos algoritmos ofrece una interpretación diferente de la red con estructura core-periphery. Por ejemplo:</p>
<ul>
<li>Louvain tiende a identificar grandes clusters, pero puede pasar por alto subestructuras dentro del núcleo.</li>
<li>Girvan-Newman es capaz de obtener clusters menores al jugar con el solapamiento.</li>
<li>Infomap ofrece una visión única basada en los flujos de información a través de la red, detectando clusters tanto en el núcleo como en la periferia.</li>
</ul>
<p>El clustering en redes biológicas es una herramienta poderosa para identificar módulos funcionales y estructuras subyacentes. Sin embargo, como hemos visto con la red core-periphery, no existe un único algoritmo que funcione para todas las redes. Cada uno tiene sus ventajas y limitaciones, y la elección del algoritmo adecuado depende de la naturaleza de la red y de los objetivos del análisis.</p>
</section>
<section id="preguntas" class="level4" data-number="3.2.3.4">
<h4 data-number="3.2.3.4" class="anchored" data-anchor-id="preguntas"><span class="header-section-number">3.2.3.4</span> Preguntas</h4>
<p><em>¿Por qué es importante considerar la centralidad de intermediación (betweenness centrality) cuando analizamos redes biológicas?</em></p>
<pre><code>La centralidad de intermediación indica cuántas veces un nodo actúa como un puente entre otros nodos a lo largo de los caminos más cortos. En redes biológicas, esto puede representar genes o proteínas clave que controlan la comunicación entre distintos módulos funcionales. Los nodos con alta centralidad de intermediación son esenciales para mantener la conectividad global de la red, y su eliminación podría fragmentar la red y aislar módulos, lo que puede tener implicaciones biológicas críticas.</code></pre>
<p><em>¿Qué diferencia hay entre la modularidad alta y baja en el clustering de redes, y cómo afecta la interpretación de los clusters?</em></p>
<pre><code>Una modularidad alta indica que los nodos dentro de un cluster están muy interconectados, y hay pocas conexiones con nodos fuera del cluster. Esto sugiere que el cluster representa un grupo funcional cohesivo. Por el contrario, una modularidad baja sugiere que los clusters no están bien definidos, con muchas conexiones externas, lo que dificulta la interpretación biológica. Los clusters con alta modularidad suelen corresponder a módulos funcionales claros, mientras que una baja modularidad puede reflejar procesos difusos o redes ruidosas.</code></pre>
<p><em>¿Qué ventajas ofrece set.seed() cuando se trabaja con redes aleatorias o algoritmos estocásticos en el análisis de redes, y en qué situaciones sería más útil?</em></p>
<pre><code>El uso de set.seed() permite que los resultados de procesos aleatorios sean reproducibles. En el análisis de redes, donde a menudo se utilizan grafos aleatorios o algoritmos estocásticos, fijar una semilla garantiza que la misma red o resultado se obtenga en cada ejecución del código. Esto es especialmente útil cuando se documentan los resultados o cuando se quiere comparar entre diferentes configuraciones o pruebas. En situaciones de enseñanza o investigación, permite que todos los involucrados trabajen con la misma estructura de red, facilitando la comprensión y el análisis.</code></pre>
<p>###Aplicando algoritmos a nuestra red</p>
<p>Crea un nuevo bloque en tus documentos Rmd y escribe el código para aplicar los tres algoritmos de agrupamiento a la red de interacción que creamos al inicio de esta práctica. Es posible que necesites consultar tus notas de la <a href="hpo_redes1.html">práctica anterior</a> para crear un objeto igraph a partir de un data.frame.</p>
<div class="callout callout-style-default callout-caution callout-titled">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-1-contents" aria-controls="callout-1" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Caution
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-1" class="callout-1-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<div class="cell">
<div class="sourceCode cell-code" id="cb14"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>g <span class="ot">&lt;-</span> <span class="fu">graph_from_data_frame</span>(interaction_network, <span class="at">directed =</span> <span class="cn">FALSE</span>)</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>cluster_louvain <span class="ot">&lt;-</span> <span class="fu">cluster_louvain</span>(g)</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">123</span>)</span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(cluster_louvain, g, <span class="at">vertex.size=</span><span class="dv">5</span>, <span class="at">vertex.label=</span><span class="cn">NA</span>, <span class="at">edge.arrow.size=</span><span class="fl">0.2</span>, <span class="at">main=</span><span class="st">"Clustering with Louvain"</span>)</span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>cluster_girvan_newman <span class="ot">&lt;-</span> <span class="fu">cluster_edge_betweenness</span>(g)</span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">123</span>)</span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(cluster_girvan_newman, g, <span class="at">vertex.size=</span><span class="dv">5</span>, <span class="at">vertex.label=</span><span class="cn">NA</span>, <span class="at">edge.arrow.size=</span><span class="fl">0.2</span>, <span class="at">main=</span><span class="st">"Clustering with Girvan-Newman"</span>)</span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a>cluster_infomap <span class="ot">&lt;-</span> <span class="fu">cluster_infomap</span>(g)</span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">123</span>)</span>
<span id="cb14-13"><a href="#cb14-13" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(cluster_infomap, g, <span class="at">vertex.size=</span><span class="dv">5</span>, <span class="at">vertex.label=</span><span class="cn">NA</span>, <span class="at">edge.arrow.size=</span><span class="fl">0.2</span>, <span class="at">main=</span><span class="st">"Clustering with Infomap"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
</div>
</div>
</section>
</section>
</section>
<section id="functional-enrichment" class="level2" data-number="3.3">
<h2 data-number="3.3" class="anchored" data-anchor-id="functional-enrichment"><span class="header-section-number">3.3</span> Functional Enrichment</h2>
<section id="introducción-al-análisis-de-enriquecimiento-funcional" class="level3" data-number="3.3.1">
<h3 data-number="3.3.1" class="anchored" data-anchor-id="introducción-al-análisis-de-enriquecimiento-funcional"><span class="header-section-number">3.3.1</span> Introducción al Análisis de Enriquecimiento Funcional</h3>
<p>El análisis de enriquecimiento funcional es un conjunto de técnicas bioinformáticas diseñadas para identificar características funcionales, rutas o procesos biológicos que están representados en exceso dentro de un conjunto de genes de interés. Estas técnicas son fundamentales para ayudar a los investigadores a interpretar grandes cantidades de datos genómicos y transcriptómicos al descubrir las funciones moleculares y procesos biológicos que son importantes en condiciones experimentales específicas, como enfermedades o tratamientos.</p>
<p>Cuando se estudia un conjunto de genes, ya sea obtenido a partir de datos de expresión diferencial, variantes genéticas, o cualquier otra fuente, el análisis de enriquecimiento nos permite responder preguntas como: ¿Qué procesos biológicos están sobrerrepresentados en este conjunto de genes? o ¿Qué funciones moleculares pueden estar relacionadas con el fenotipo de interés?</p>
<section id="tipos-de-análisis-de-enriquecimiento" class="level4" data-number="3.3.1.1">
<h4 data-number="3.3.1.1" class="anchored" data-anchor-id="tipos-de-análisis-de-enriquecimiento"><span class="header-section-number">3.3.1.1</span> Tipos de Análisis de Enriquecimiento</h4>
<p>Existen diferentes enfoques para el análisis de enriquecimiento, cada uno de los cuales responde a distintas preguntas de investigación y métodos estadísticos. Los más comunes incluyen:</p>
<ol type="1">
<li>Análisis de Sobrerrepresentación (Over-Representation Analysis, ORA):</li>
</ol>
<p>Propósito: Determinar si ciertas funciones biológicas (por ejemplo, términos de Gene Ontology (GO), rutas de KEGG) están sobrerrepresentadas en un conjunto de genes de interés en comparación con un conjunto de fondo o referencia. Método: Se utiliza una prueba estadística (como la prueba exacta de Fisher) para evaluar si la frecuencia observada de un término es mayor de lo esperado al azar en el conjunto de interés.</p>
<ol start="2" type="1">
<li>Análisis de Enriquecimiento Basado en Rango (Gene Set Enrichment Analysis, GSEA):</li>
</ol>
<p>Propósito: Identificar conjuntos de genes que muestran una tendencia a ubicarse en las posiciones más altas o bajas en una lista ordenada de acuerdo a una variable continua, como el nivel de expresión. Método: En lugar de seleccionar un subconjunto específico de genes, GSEA evalúa el enriquecimiento en función de la posición en una lista clasificada, eliminando la necesidad de un umbral de significancia arbitrario. Selección del Método de Enriquecimiento Cada método tiene sus ventajas y limitaciones. El ORA es útil cuando ya se ha definido un conjunto específico de genes de interés, mientras que GSEA es particularmente valioso en análisis exploratorios donde no se requiere un corte específico de significancia para definir los genes de interés. Elegir entre estos métodos depende del diseño del experimento y de la naturaleza de los datos.</p>
</section>
</section>
<section id="enfoque-práctico-análisis-de-sobrerrepresentación-ora" class="level3" data-number="3.3.2">
<h3 data-number="3.3.2" class="anchored" data-anchor-id="enfoque-práctico-análisis-de-sobrerrepresentación-ora"><span class="header-section-number">3.3.2</span> Enfoque Práctico: Análisis de Sobrerrepresentación (ORA)</h3>
<p>En esta práctica, aplicaremos el enfoque de Análisis de Sobrerrepresentación (ORA) para explorar la representación de términos de Gene Ontology (GO) y rutas moleculares en un conjunto específico de genes de interés. Optamos por ORA en lugar de otros métodos como el Análisis de Enriquecimiento Basado en Rango (GSEA) porque en este caso disponemos de un conjunto bien definido de genes, asociados con el fenotipo de “Morfología Anormal del Corpúsculo Renal” en el Human Phenotype Ontology (HPO). Para aplicar GSEA, se requiere una lista completa de genes clasificados y un puntaje asociado a cada gen, lo cual no es aplicable en este escenario.</p>
<p>Con ORA, podremos determinar si ciertos procesos biológicos o rutas están sobrerrepresentados en este conjunto específico de genes en comparación con un fondo de referencia. Utilizaremos el paquete clusterProfiler en R para realizar este análisis y visualizar los resultados, descubriendo los procesos biológicos relevantes que podrían estar implicados en la estructura y función del corpúsculo renal en condiciones anormales.</p>
<section id="teoría-del-análisis-de-sobrerrepresentación-over-representation-analysis-ora" class="level4" data-number="3.3.2.1">
<h4 data-number="3.3.2.1" class="anchored" data-anchor-id="teoría-del-análisis-de-sobrerrepresentación-over-representation-analysis-ora"><span class="header-section-number">3.3.2.1</span> Teoría del Análisis de Sobrerrepresentación (Over-Representation Analysis, ORA)</h4>
<p>Análisis de Sobrerrepresentación (ORA) es una técnica estadística que se utiliza para determinar si ciertos términos funcionales (por ejemplo, categorías de Gene Ontology (GO) o rutas de KEGG) están sobrerrepresentados en un conjunto de genes de interés en comparación con un conjunto de genes de fondo. Este tipo de análisis se usa comúnmente para identificar procesos biológicos o rutas moleculares relevantes a partir de datos de expresión diferencial, redes génicas, o cualquier otro conjunto de genes.</p>
</section>
<section id="conceptos-básicos-del-ora" class="level4" data-number="3.3.2.2">
<h4 data-number="3.3.2.2" class="anchored" data-anchor-id="conceptos-básicos-del-ora"><span class="header-section-number">3.3.2.2</span> Conceptos Básicos del ORA</h4>
<ul>
<li><p>Conjunto de Genes de Interés: Este conjunto contiene los genes seleccionados para el análisis. En el contexto de una enfermedad o condición, puede incluir genes diferencialmente expresados o genes relacionados con un fenotipo específico.</p></li>
<li><p>Conjunto de Fondo (Background): Para comparar la frecuencia de los términos en el conjunto de interés, necesitamos definir un grupo de genes de referencia o fondo, que suele ser el conjunto de todos los genes expresados en el experimento o todos los genes de un organismo.</p></li>
<li><p>Pruebas Estadísticas: ORA generalmente utiliza pruebas estadísticas como la prueba exacta de Fisher o la prueba de Chi-cuadrado para determinar si la frecuencia de un término funcional es mayor de lo esperado al azar en el conjunto de interés. La prueba estadística proporciona un valor de p, que puede ajustarse para el control de descubrimientos falsos.</p></li>
<li><p>Pasos para Realizar un ORA</p>
<ol type="1">
<li>Definir el conjunto de genes de interés y el conjunto de fondo.</li>
<li>Mapear los genes a términos funcionales (por ejemplo, a términos de GO o rutas de KEGG).</li>
<li>Calcular la frecuencia de cada término en ambos conjuntos y aplicar una prueba estadística para evaluar la significancia.</li>
<li>Interpretar los resultados, teniendo en cuenta el contexto biológico y el ajuste de p-valores.</li>
</ol></li>
</ul>
</section>
</section>
<section id="ora-aplicado-a-genes-asociados-con-el-término-hpo-morfología-anormal-del-corpúsculo-renal" class="level3" data-number="3.3.3">
<h3 data-number="3.3.3" class="anchored" data-anchor-id="ora-aplicado-a-genes-asociados-con-el-término-hpo-morfología-anormal-del-corpúsculo-renal"><span class="header-section-number">3.3.3</span> ORA aplicado a Genes Asociados con el Término HPO “Morfología Anormal del Corpúsculo Renal”</h3>
<p>Vamos a realizar un análisis ORA usando el paquete clusterProfiler en R. Para ilustrar el procedimiento, consideraremos genes asociados con el término del Human Phenotype Ontology (HPO) “Morfología Anormal del Corpúsculo Renal” (abnormal renal corpuscle morphology). Este análisis identificará procesos o rutas biológicas que están sobrerrepresentados en este grupo de genes.</p>
<p>clusterProfiler ofrece la función enrichGO para realizar el análisis de enriquecimiento basado en términos de GO. Vamos a ejecutarlo sobre nuestros genes de interés.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb15"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> (<span class="sc">!</span><span class="fu">requireNamespace</span>(<span class="st">"clusterProfiler"</span>, <span class="at">quietly =</span> <span class="cn">TRUE</span>)) BiocManager<span class="sc">::</span><span class="fu">install</span>(<span class="st">"clusterProfiler"</span>)</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> (<span class="sc">!</span><span class="fu">requireNamespace</span>(<span class="st">"org.Hs.eg.db"</span>, <span class="at">quietly =</span> <span class="cn">TRUE</span>)) BiocManager<span class="sc">::</span><span class="fu">install</span>(<span class="st">"org.Hs.eg.db"</span>)</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(clusterProfiler)</span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(org.Hs.eg.db) <span class="co"># Base de datos de genes humanos</span></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Execute ORA enrichment analysis</span></span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a>enrich_results <span class="ot">&lt;-</span> <span class="fu">enrichGO</span>(</span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a>  <span class="at">gene          =</span> genes<span class="sc">$</span>name,      <span class="co"># Set of genes of interest (from HPO in this case)</span></span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a>  <span class="at">OrgDb         =</span> org.Hs.eg.db,        <span class="co"># Gene annotation database</span></span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a>  <span class="at">keyType       =</span> <span class="st">"SYMBOL"</span>,            <span class="co"># Type of gene identification (here, gene symbols)</span></span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true" tabindex="-1"></a>  <span class="at">ont           =</span> <span class="st">"BP"</span>,                <span class="co"># Ontology (BP: biological processes)</span></span>
<span id="cb15-13"><a href="#cb15-13" aria-hidden="true" tabindex="-1"></a>  <span class="at">pAdjustMethod =</span> <span class="st">"BH"</span>,                <span class="co"># Method for p-value adjustment</span></span>
<span id="cb15-14"><a href="#cb15-14" aria-hidden="true" tabindex="-1"></a>  <span class="at">pvalueCutoff  =</span> <span class="fl">0.05</span>,                <span class="co"># Significance threshold for p-value</span></span>
<span id="cb15-15"><a href="#cb15-15" aria-hidden="true" tabindex="-1"></a>  <span class="at">qvalueCutoff  =</span> <span class="fl">0.2</span>                  <span class="co"># Significance threshold for q-value</span></span>
<span id="cb15-16"><a href="#cb15-16" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb15-17"><a href="#cb15-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-18"><a href="#cb15-18" aria-hidden="true" tabindex="-1"></a><span class="co"># Mostrar resultados</span></span>
<span id="cb15-19"><a href="#cb15-19" aria-hidden="true" tabindex="-1"></a><span class="fu">head</span>(enrich_results)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="explicación-de-argumentos-clave-en-enrichgo" class="level3" data-number="3.3.4">
<h3 data-number="3.3.4" class="anchored" data-anchor-id="explicación-de-argumentos-clave-en-enrichgo"><span class="header-section-number">3.3.4</span> Explicación de Argumentos Clave en enrichGO</h3>
<ul>
<li>gene: La lista de genes de interés. En este caso, es una lista de genes asociados con el fenotipo del HPO.</li>
<li>OrgDb: Base de datos que contiene la información de anotación de genes (en este caso, org.Hs.eg.db para genes humanos).</li>
<li>keyType: Tipo de identificación de los genes (por ejemplo, “SYMBOL” para nombres de genes, “ENTREZID” para IDs de Entrez).</li>
<li>ont: Especifica la ontología GO (BP: Biological Process, MF: Molecular Function, CC: Cellular Component).</li>
<li>pAdjustMethod: Método para ajustar los valores de p, siendo “BH” (Benjamini-Hochberg) una elección común.</li>
<li>pvalueCutoff y qvalueCutoff: Define los umbrales de significancia para p-valores y q-valores.</li>
</ul>
<div class="callout callout-style-default callout-caution callout-titled">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-2-contents" aria-controls="callout-2" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
P and Q values
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-2" class="callout-2-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p>El valor p y el valor q son métricas utilizadas en pruebas estadísticas para evaluar la significancia de los resultados, aunque tienen propósitos ligeramente diferentes:</p>
<ul>
<li><p>Valor p: Representa la probabilidad de que los resultados observados (o más extremos) ocurran por azar si no hubiera un efecto real. En el contexto de análisis de enriquecimiento, un valor p bajo indica que un término o vía específica probablemente esté enriquecido en el conjunto de genes debido a una asociación verdadera y no al azar. Sin embargo, cuando se prueban múltiples hipótesis (como en un análisis de enriquecimiento con muchos términos), el uso de valores p sin ajuste puede llevar a una alta tasa de falsos positivos.</p></li>
<li><p>Valor q: Es una forma ajustada del valor p que se enfoca en controlar la tasa de descubrimientos falsos (FDR), o sea, la proporción esperada de falsos positivos entre todos los resultados positivos. El valor q considera las múltiples comparaciones y es especialmente útil en análisis de enriquecimiento, donde se prueban muchos términos. Un umbral de valor q (como q &lt; 0.2) ayuda a limitar el porcentaje de descubrimientos falsos, y es una forma más conservadora de interpretar resultados con muchas pruebas.</p></li>
</ul>
<p>En resumen:</p>
<ul>
<li>Valor p es la medida de significancia estadística sin ajuste.</li>
<li>Valor q es el valor p ajustado para controlar la tasa de descubrimientos falsos, proporcionando una estimación más confiable de la significancia en pruebas de gran escala.</li>
</ul>
<section id="pregunta-de-reflexión" class="level4" data-number="3.3.4.1">
<h4 data-number="3.3.4.1" class="anchored" data-anchor-id="pregunta-de-reflexión"><span class="header-section-number">3.3.4.1</span> Pregunta de reflexión:</h4>
<p><em>¿Por qué es importante considerar tanto el valor p como el valor q al interpretar los resultados de un análisis de enriquecimiento?</em></p>
<pre><code>El valor p nos da una medida de la significancia estadística de los resultados, indicando qué tan probable es que un término esté enriquecido debido a una asociación verdadera y no al azar. Sin embargo, en análisis de enriquecimiento, donde se evalúan múltiples términos de manera simultánea, el valor p sin ajustar podría conducir a una alta tasa de falsos positivos. Por ello, el valor q es crucial, ya que ajusta el valor p para controlar la tasa de descubrimientos falsos (FDR), proporcionando una interpretación más confiable y conservadora de los resultados. Usar ambos valores ayuda a evitar conclusiones erróneas y a identificar términos que tienen una relevancia más sólida en el contexto del análisis.</code></pre>
</section>
</div>
</div>
</div>
</section>
<section id="visualización-de-los-resultados-de-enriquecimiento" class="level3" data-number="3.3.5">
<h3 data-number="3.3.5" class="anchored" data-anchor-id="visualización-de-los-resultados-de-enriquecimiento"><span class="header-section-number">3.3.5</span> Visualización de los Resultados de Enriquecimiento</h3>
<p>clusterProfiler permite visualizar términos GO enriquecidos con dotplot y barplot.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb17"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> (<span class="sc">!</span><span class="fu">requireNamespace</span>(<span class="st">"enrichplot"</span>, <span class="at">quietly =</span> <span class="cn">TRUE</span>)) BiocManager<span class="sc">::</span><span class="fu">install</span>(<span class="st">"enrichplot"</span>)</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(enrichplot)</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Dotplot to visualize enriched GO terms</span></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a><span class="fu">dotplot</span>(enrich_results, <span class="at">showCategory =</span> <span class="dv">10</span>, <span class="at">title =</span> <span class="st">"GO Enrichment for Abnormal Renal Corpuscle Morphology"</span>)</span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Barplot as an alternative</span></span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a><span class="fu">barplot</span>(enrich_results, <span class="at">showCategory =</span> <span class="dv">10</span>, <span class="at">title =</span> <span class="st">"GO Enrichment Barplot"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<section id="también-podemos-exportar-los-resultados-a-csv-o-visualizarlos-en-tablas." class="level4" data-number="3.3.5.1">
<h4 data-number="3.3.5.1" class="anchored" data-anchor-id="también-podemos-exportar-los-resultados-a-csv-o-visualizarlos-en-tablas."><span class="header-section-number">3.3.5.1</span> También podemos exportar los resultados a CSV o visualizarlos en tablas.</h4>
<div class="cell">
<div class="sourceCode cell-code" id="cb18"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Convert results to data frame and export to CSV</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a><span class="fu">write.csv2</span>(<span class="fu">as.data.frame</span>(enrich_results), <span class="at">file =</span> <span class="st">"GO_Enrichment_Abnormal_Renal_Corpuscle.csv"</span>, <span class="at">row.names =</span> <span class="cn">FALSE</span>)</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a><span class="co"># View as a table in R</span></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a><span class="fu">head</span>(<span class="fu">as.data.frame</span>(enrich_results))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
</section>
<section id="análisis-de-enriquecimiento-en-clusters-de-una-red" class="level3" data-number="3.3.6">
<h3 data-number="3.3.6" class="anchored" data-anchor-id="análisis-de-enriquecimiento-en-clusters-de-una-red"><span class="header-section-number">3.3.6</span> Análisis de Enriquecimiento en Clusters de una Red</h3>
<p>Cuando trabajamos con redes de genes, el análisis de enriquecimiento funcional puede aplicarse a clusters individuales para identificar funciones únicas en cada grupo de genes.</p>
<p>Para realizar un Análisis de Enriquecimiento en Clusters de una Red en R, partiremos tambien de la red STRINGdb del termino HPO “abnormal renal corpuscle morphology” que ya ha sido agrupada en diferentes clusters (por ejemplo, usando el algoritmo de Louvain en una sección previa). Esto permite aplicar análisis de enriquecimiento a cada uno de los clusters obtenidos para identificar funciones biológicas o rutas moleculares específicas asociadas con cada grupo de genes.</p>
<section id="extracción-de-genes-de-clusters-para-análisis-de-enriquecimiento" class="level4" data-number="3.3.6.1">
<h4 data-number="3.3.6.1" class="anchored" data-anchor-id="extracción-de-genes-de-clusters-para-análisis-de-enriquecimiento"><span class="header-section-number">3.3.6.1</span> Extracción de Genes de Clusters para Análisis de Enriquecimiento</h4>
<ul>
<li>Asignación de Clusters a los Nodos: Partimos de un grafo en el que cada nodo ya tiene asignado un número de cluster.</li>
<li>Extracción de Genes por Cluster: Utilizamos una función para extraer los genes de cada cluster.</li>
</ul>
<p>El siguiente código ilustra cómo extraer los genes de cada cluster en el grafo previamente agrupado del termino HPO.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb19"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Create the graph</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>g <span class="ot">&lt;-</span> <span class="fu">graph_from_data_frame</span>(interaction_network, <span class="at">directed =</span> <span class="cn">FALSE</span>)</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>cluster_louvain <span class="ot">&lt;-</span> <span class="fu">cluster_louvain</span>(g)</span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">123</span>)</span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a>cluster_membership <span class="ot">&lt;-</span> <span class="fu">membership</span>(<span class="fu">cluster_louvain</span>(g)) <span class="co"># Louvain clustering on the graph</span></span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Split genes by cluster</span></span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a>genes_clusters <span class="ot">&lt;-</span> <span class="fu">split</span>(<span class="fu">V</span>(g)<span class="sc">$</span>name, cluster_membership)  <span class="co"># Names of genes by cluster</span></span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-10"><a href="#cb19-10" aria-hidden="true" tabindex="-1"></a><span class="co"># Look at the genes in each cluster. What pathways/GO terms do you think might be enriched?</span></span>
<span id="cb19-11"><a href="#cb19-11" aria-hidden="true" tabindex="-1"></a><span class="fu">print</span>(genes_clusters)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="aplicación-del-análisis-de-enriquecimiento-ora-en-cada-cluster" class="level4" data-number="3.3.6.2">
<h4 data-number="3.3.6.2" class="anchored" data-anchor-id="aplicación-del-análisis-de-enriquecimiento-ora-en-cada-cluster"><span class="header-section-number">3.3.6.2</span> Aplicación del Análisis de Enriquecimiento ORA en Cada Cluster</h4>
<p>Con los genes divididos por clusters, aplicaremos el análisis de enriquecimiento Over-Representation Analysis (ORA) en cada uno. Esto permite identificar procesos biológicos o funciones moleculares específicas para los genes de cada grupo. Usaremos el paquete clusterProfiler y nos enfocaremos en el análisis de enriquecimiento GO.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb20"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Initialize an empty list to store enrichment results for each cluster</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>enrichment_results_clusters <span class="ot">&lt;-</span> <span class="fu">list</span>()</span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Loop over each cluster to perform enrichment analysis</span></span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> (i <span class="cf">in</span> <span class="fu">seq_along</span>(genes_clusters)) {</span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a>  <span class="fu">cat</span>(i, <span class="st">"</span><span class="sc">\n</span><span class="st">"</span>)</span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Perform GO enrichment for the current cluster</span></span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a>  enrichment_results_clusters[[i]] <span class="ot">&lt;-</span> <span class="fu">enrichGO</span>(</span>
<span id="cb20-9"><a href="#cb20-9" aria-hidden="true" tabindex="-1"></a>    <span class="at">gene          =</span> genes_clusters[[i]],   <span class="co"># Set of genes for the current cluster</span></span>
<span id="cb20-10"><a href="#cb20-10" aria-hidden="true" tabindex="-1"></a>    <span class="at">OrgDb         =</span> org.Hs.eg.db,          <span class="co"># Database for gene annotation</span></span>
<span id="cb20-11"><a href="#cb20-11" aria-hidden="true" tabindex="-1"></a>    <span class="at">keyType       =</span> <span class="st">"SYMBOL"</span>,              <span class="co"># Identifier type (e.g., gene symbols)</span></span>
<span id="cb20-12"><a href="#cb20-12" aria-hidden="true" tabindex="-1"></a>    <span class="at">ont           =</span> <span class="st">"BP"</span>,                  <span class="co"># Ontology (BP: Biological Process)</span></span>
<span id="cb20-13"><a href="#cb20-13" aria-hidden="true" tabindex="-1"></a>    <span class="at">pAdjustMethod =</span> <span class="st">"BH"</span>,                  <span class="co"># Method for p-value adjustment</span></span>
<span id="cb20-14"><a href="#cb20-14" aria-hidden="true" tabindex="-1"></a>    <span class="at">pvalueCutoff  =</span> <span class="fl">0.05</span>,                  <span class="co"># Significance threshold for p-value</span></span>
<span id="cb20-15"><a href="#cb20-15" aria-hidden="true" tabindex="-1"></a>    <span class="at">qvalueCutoff  =</span> <span class="fl">0.2</span>                    <span class="co"># Significance threshold for q-value</span></span>
<span id="cb20-16"><a href="#cb20-16" aria-hidden="true" tabindex="-1"></a>  )</span>
<span id="cb20-17"><a href="#cb20-17" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb20-18"><a href="#cb20-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-19"><a href="#cb20-19" aria-hidden="true" tabindex="-1"></a><span class="co"># Visualize results for the first cluster as an example</span></span>
<span id="cb20-20"><a href="#cb20-20" aria-hidden="true" tabindex="-1"></a><span class="fu">dotplot</span>(enrichment_results_clusters[[<span class="dv">1</span>]], <span class="at">showCategory =</span> <span class="dv">10</span>, <span class="at">title =</span> <span class="st">"GO Enrichment for Cluster 1"</span>)</span>
<span id="cb20-21"><a href="#cb20-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-22"><a href="#cb20-22" aria-hidden="true" tabindex="-1"></a><span class="co"># Save enrichment results to CSV files for each cluster</span></span>
<span id="cb20-23"><a href="#cb20-23" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> (i <span class="cf">in</span> <span class="fu">seq_along</span>(enrichment_results_clusters)) {</span>
<span id="cb20-24"><a href="#cb20-24" aria-hidden="true" tabindex="-1"></a>  <span class="fu">write.csv2</span>(</span>
<span id="cb20-25"><a href="#cb20-25" aria-hidden="true" tabindex="-1"></a>    <span class="fu">as.data.frame</span>(enrichment_results_clusters[[i]]),  <span class="co"># Convert to data frame for saving</span></span>
<span id="cb20-26"><a href="#cb20-26" aria-hidden="true" tabindex="-1"></a>    <span class="at">file =</span> <span class="fu">paste0</span>(<span class="st">"enrichment_cluster_"</span>, i, <span class="st">".csv"</span>)   <span class="co"># File name based on cluster index</span></span>
<span id="cb20-27"><a href="#cb20-27" aria-hidden="true" tabindex="-1"></a>  )</span>
<span id="cb20-28"><a href="#cb20-28" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Ahora utiliza un dotplot para visualizar los resultados de los primeros, terceros y cuartos clusters. ¿Cómo se comparan los resultados con la intuición formada al mirar las listas de genes?</p>
</section>
<section id="preguntas-1" class="level4" data-number="3.3.6.3">
<h4 data-number="3.3.6.3" class="anchored" data-anchor-id="preguntas-1"><span class="header-section-number">3.3.6.3</span> Preguntas</h4>
<p><em>¿Por qué es importante el análisis de enriquecimiento funcional?</em> El análisis de enriquecimiento funcional es fundamental en bioinformática porque permite a los investigadores identificar patrones significativos dentro de grandes conjuntos de datos genómicos y transcriptómicos. Al revelar qué procesos biológicos, rutas o funciones moleculares están sobrerrepresentados en un conjunto de genes, facilita la interpretación de los resultados experimentales. Esto es esencial para formular hipótesis sobre la biología subyacente de enfermedades o tratamientos y para priorizar futuras investigaciones.</p>
<p><em>¿Cómo deberíamos interpretar los resultados del análisis de enriquecimiento?</em></p>
<pre><code>La interpretación de los términos enriquecidos depende del contexto biológico de los genes de interés. Por ejemplo, si los genes seleccionados están asociados con una enfermedad renal, los términos enriquecidos relacionados con funciones como la apoptosis o la inflamación pueden indicar procesos relevantes en la patología. Comprender el contexto ayuda a filtrar los resultados y a dirigir la investigación hacia áreas biológicamente significativas.</code></pre>
<p><em>¿Por qué son importantes las visualizaciones de datos para el análisis de enriquecimiento?</em></p>
<pre><code>Las visualizaciones, como los dotplots y emapplots, son esenciales para comprender y comunicar los resultados del análisis de enriquecimiento. Estas herramientas permiten a los investigadores identificar rápidamente patrones, relaciones y la relevancia de diferentes términos enriquecidos en el contexto de su conjunto de genes. La visualización facilita destacar hallazgos clave y presentar los resultados de manera más accesible, fomentando colaboraciones y discusiones entre investigadores.</code></pre>
<p><em>¿Qué conocimientos se pueden obtener al realizar un análisis de enriquecimiento en clusters de una red?</em></p>
<pre><code>Realizar un análisis de enriquecimiento en clusters de una red puede revelar diferencias significativas en los términos enriquecidos a lo largo de grupos de genes. Por ejemplo, un cluster que agrupa genes involucrados en la respuesta inmune puede mostrar un enriquecimiento en términos relacionados con la inflamación, mientras que otro cluster puede estar enriquecido en términos relacionados con la regulación del ciclo celular. Estas diferencias ofrecen una visión de cómo diferentes grupos de genes contribuyen a procesos biológicos específicos, ayudando a delimitar funciones y relaciones dentro de la red.</code></pre>
<p><em>¿Cómo informan los resultados de enriquecimiento sobre la relación entre genes y fenotipo?</em></p>
<pre><code>Los resultados del análisis de enriquecimiento pueden proporcionar información sobre la relación entre los genes analizados y el fenotipo de interés, como la morfología anormal del corpúsculo renal. Si los términos enriquecidos sugieren una disfunción en procesos como la filtración o la regulación del crecimiento celular, esto puede implicar mecanismos biológicos subyacentes al fenotipo observado. Este conocimiento es valioso para comprender mejor la biología de la enfermedad y potencialmente guiar investigaciones futuras hacia objetivos terapéuticos.</code></pre>
<p><em>¿Cuáles son algunas aplicaciones prácticas del análisis de enriquecimiento?</em></p>
<pre><code>El análisis de enriquecimiento tiene muchas aplicaciones prácticas, como el desarrollo de tratamientos y la comprensión de enfermedades. Por ejemplo, identificar rutas biológicas alteradas en un tipo específico de cáncer puede ayudar a los investigadores a diseñar terapias dirigidas a estas rutas. También es útil en estudios de farmacogenómica, donde el objetivo es comprender cómo las variaciones genéticas influyen en la respuesta a los medicamentos. Estos análisis proporcionan conocimientos que pueden guiar la investigación traslacional y la práctica clínica, mejorando la precisión y efectividad de las intervenciones médicas.</code></pre>
</section>
</section>
<section id="otros-métodos-de-visualización-en-clusterprofiler" class="level3" data-number="3.3.7">
<h3 data-number="3.3.7" class="anchored" data-anchor-id="otros-métodos-de-visualización-en-clusterprofiler"><span class="header-section-number">3.3.7</span> Otros métodos de visualización en clusterProfiler:</h3>
<p>dotplot: El dotplot muestra el enriquecimiento de términos en diferentes clusters de genes. Cada punto representa un término, donde el tamaño indica el nivel de significancia o la cantidad de genes asociados. Es útil para identificar patrones de enriquecimiento y comparar la relevancia de varios términos entre clusters.</p>
<p>emapplot: El emapplot visualiza las relaciones entre los términos de enriquecimiento, mostrando cómo se conectan entre sí. Los nodos representan términos y las conexiones indican similitudes o superposiciones. Este gráfico es útil para entender la estructura de los términos en un contexto más amplio.</p>
<p>Ahora consulta la página de ayuda para estas funciones y úsalas para graficar algunos de tus clusters.</p>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="./hpo_redes1.html" class="pagination-link" aria-label="Practica Redes 1: Análisis de redes con R y iGRAPH:">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Practica Redes 1: Análisis de redes con R y iGRAPH:</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="./summary.html" class="pagination-link" aria-label="Summary">
        <span class="nav-page-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Summary</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->




</body></html>